
main.out:     file format elf32-littlearm


Disassembly of section .text:

00000000 <myvectors>:
       0:	00 08 00 20 11 00 00 00 e9 00 00 00 f5 00 00 00     ... ............

00000010 <main>:
 *
 * Description: The main subroutine
 *
 *************************************************************************/
int main(void)
{
      10:	b580      	push	{r7, lr}
      12:	b082      	sub	sp, #8
      14:	af00      	add	r7, sp, #0
	
	*NVIC_CCR = *NVIC_CCR | 0x200; /* Set STKALIGN in NVIC */
      16:	f64e 5314 	movw	r3, #60692	; 0xed14
      1a:	f2ce 0300 	movt	r3, #57344	; 0xe000
      1e:	f64e 5214 	movw	r2, #60692	; 0xed14
      22:	f2ce 0200 	movt	r2, #57344	; 0xe000
      26:	6812      	ldr	r2, [r2, #0]
      28:	f442 7200 	orr.w	r2, r2, #512	; 0x200
      2c:	601a      	str	r2, [r3, #0]
	// Init clock system
	  Clk_Init();
      2e:	f000 f879 	bl	124 <Clk_Init>
          
          unsigned int i;
    
          
	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
      32:	f04f 0001 	mov.w	r0, #1
      36:	f04f 0101 	mov.w	r1, #1
      3a:	f000 fc47 	bl	8cc <RCC_APB2PeriphClockCmd>
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOA, ENABLE);
      3e:	f04f 0014 	mov.w	r0, #20
      42:	f04f 0101 	mov.w	r1, #1
      46:	f000 fc41 	bl	8cc <RCC_APB2PeriphClockCmd>
					
	
	        // Configure PC.12 as output push-pull (LED)
	        GPIO_WriteBit(GPIOC,GPIO_Pin_12,Bit_SET);
      4a:	f241 0000 	movw	r0, #4096	; 0x1000
      4e:	f2c4 0001 	movt	r0, #16385	; 0x4001
      52:	f44f 5180 	mov.w	r1, #4096	; 0x1000
      56:	f04f 0201 	mov.w	r2, #1
      5a:	f000 ff73 	bl	f44 <GPIO_WriteBit>
	        GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_12;
      5e:	f240 0300 	movw	r3, #0
      62:	f2c2 0300 	movt	r3, #8192	; 0x2000
      66:	f44f 5280 	mov.w	r2, #4096	; 0x1000
      6a:	801a      	strh	r2, [r3, #0]
	        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
      6c:	f240 0300 	movw	r3, #0
      70:	f2c2 0300 	movt	r3, #8192	; 0x2000
      74:	f04f 0210 	mov.w	r2, #16
      78:	70da      	strb	r2, [r3, #3]
	        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
      7a:	f240 0300 	movw	r3, #0
      7e:	f2c2 0300 	movt	r3, #8192	; 0x2000
      82:	f04f 0203 	mov.w	r2, #3
      86:	709a      	strb	r2, [r3, #2]
	        GPIO_Init(GPIOC, &GPIO_InitStructure);
      88:	f241 0000 	movw	r0, #4096	; 0x1000
      8c:	f2c4 0001 	movt	r0, #16385	; 0x4001
      90:	f240 0100 	movw	r1, #0
      94:	f2c2 0100 	movt	r1, #8192	; 0x2000
      98:	f000 fe04 	bl	ca4 <GPIO_Init>


	  while(1)
		{
		  
	            GPIOC->BRR |= 0x00001000;
      9c:	f241 0300 	movw	r3, #4096	; 0x1000
      a0:	f2c4 0301 	movt	r3, #16385	; 0x4001
      a4:	f241 0200 	movw	r2, #4096	; 0x1000
      a8:	f2c4 0201 	movt	r2, #16385	; 0x4001
      ac:	6952      	ldr	r2, [r2, #20]
      ae:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
      b2:	615a      	str	r2, [r3, #20]
	            myDelay(500000);
      b4:	f24a 1020 	movw	r0, #41248	; 0xa120
      b8:	f2c0 0007 	movt	r0, #7
      bc:	f000 f820 	bl	100 <myDelay>
	            GPIOC->BSRR |= 0x00001000;
      c0:	f241 0300 	movw	r3, #4096	; 0x1000
      c4:	f2c4 0301 	movt	r3, #16385	; 0x4001
      c8:	f241 0200 	movw	r2, #4096	; 0x1000
      cc:	f2c4 0201 	movt	r2, #16385	; 0x4001
      d0:	6912      	ldr	r2, [r2, #16]
      d2:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
      d6:	611a      	str	r2, [r3, #16]
	            myDelay(500000);
      d8:	f24a 1020 	movw	r0, #41248	; 0xa120
      dc:	f2c0 0007 	movt	r0, #7
      e0:	f000 f80e 	bl	100 <myDelay>
	      }
      e4:	e7da      	b.n	9c <main+0x8c>
      e6:	bf00      	nop

000000e8 <nmi_handler>:
}
void nmi_handler(void)
{
      e8:	b480      	push	{r7}
      ea:	af00      	add	r7, sp, #0
	return ;
}
      ec:	46bd      	mov	sp, r7
      ee:	bc80      	pop	{r7}
      f0:	4770      	bx	lr
      f2:	bf00      	nop

000000f4 <hardfault_handler>:

void hardfault_handler(void)
{
      f4:	b480      	push	{r7}
      f6:	af00      	add	r7, sp, #0
	return ;
}
      f8:	46bd      	mov	sp, r7
      fa:	bc80      	pop	{r7}
      fc:	4770      	bx	lr
      fe:	bf00      	nop

00000100 <myDelay>:
//Functions definitions
void myDelay(unsigned long delay )
{ 
     100:	b480      	push	{r7}
     102:	b083      	sub	sp, #12
     104:	af00      	add	r7, sp, #0
     106:	6078      	str	r0, [r7, #4]
  while(delay) delay--;
     108:	e003      	b.n	112 <myDelay+0x12>
     10a:	687b      	ldr	r3, [r7, #4]
     10c:	f103 33ff 	add.w	r3, r3, #4294967295
     110:	607b      	str	r3, [r7, #4]
     112:	687b      	ldr	r3, [r7, #4]
     114:	2b00      	cmp	r3, #0
     116:	d1f8      	bne.n	10a <myDelay+0xa>
}
     118:	f107 070c 	add.w	r7, r7, #12
     11c:	46bd      	mov	sp, r7
     11e:	bc80      	pop	{r7}
     120:	4770      	bx	lr
     122:	bf00      	nop

00000124 <Clk_Init>:
 * Description: Init clock system
 *
 *************************************************************************/

void Clk_Init (void)
{
     124:	b580      	push	{r7, lr}
     126:	af00      	add	r7, sp, #0
  // 1. Cloking the controller from internal HSI RC (8 MHz)
  RCC_HSICmd(ENABLE);
     128:	f04f 0001 	mov.w	r0, #1
     12c:	f000 f920 	bl	370 <RCC_HSICmd>
  // wait until the HSI is ready
  while(RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
     130:	f04f 0020 	mov.w	r0, #32
     134:	f000 fcaa 	bl	a8c <RCC_GetFlagStatus>
     138:	4603      	mov	r3, r0
     13a:	2b00      	cmp	r3, #0
     13c:	d0f8      	beq.n	130 <Clk_Init+0xc>
  RCC_SYSCLKConfig(RCC_SYSCLKSource_HSI);
     13e:	f04f 0000 	mov.w	r0, #0
     142:	f000 f95b 	bl	3fc <RCC_SYSCLKConfig>
  // 2. Enable ext. high frequency OSC
  RCC_HSEConfig(RCC_HSE_ON);
     146:	f44f 3080 	mov.w	r0, #65536	; 0x10000
     14a:	f000 f8ab 	bl	2a4 <RCC_HSEConfig>
  // wait until the HSE is ready
  while(RCC_GetFlagStatus(RCC_FLAG_HSERDY) == RESET);
     14e:	f04f 0031 	mov.w	r0, #49	; 0x31
     152:	f000 fc9b 	bl	a8c <RCC_GetFlagStatus>
     156:	4603      	mov	r3, r0
     158:	2b00      	cmp	r3, #0
     15a:	d0f8      	beq.n	14e <Clk_Init+0x2a>
  // 3. Init PLL
  RCC_PLLConfig(RCC_PLLSource_HSE_Div1,RCC_PLLMul_9); // 72MHz
     15c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
     160:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
     164:	f000 f914 	bl	390 <RCC_PLLConfig>
//  RCC_PLLConfig(RCC_PLLSource_HSE_Div2,RCC_PLLMul_9); // 72MHz
  RCC_PLLCmd(ENABLE);
     168:	f04f 0001 	mov.w	r0, #1
     16c:	f000 f936 	bl	3dc <RCC_PLLCmd>
  // wait until the PLL is ready
  while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
     170:	f04f 0039 	mov.w	r0, #57	; 0x39
     174:	f000 fc8a 	bl	a8c <RCC_GetFlagStatus>
     178:	4603      	mov	r3, r0
     17a:	2b00      	cmp	r3, #0
     17c:	d0f8      	beq.n	170 <Clk_Init+0x4c>
  // 4. Set system clock divders
  RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
     17e:	f04f 0000 	mov.w	r0, #0
     182:	f000 fa05 	bl	590 <RCC_USBCLKConfig>
  RCC_ADCCLKConfig(RCC_PCLK2_Div8);
     186:	f44f 4040 	mov.w	r0, #49152	; 0xc000
     18a:	f000 fa11 	bl	5b0 <RCC_ADCCLKConfig>
  RCC_PCLK2Config(RCC_HCLK_Div1);
     18e:	f04f 0000 	mov.w	r0, #0
     192:	f000 f9a7 	bl	4e4 <RCC_PCLK2Config>
  RCC_PCLK1Config(RCC_HCLK_Div2);
     196:	f44f 6080 	mov.w	r0, #1024	; 0x400
     19a:	f000 f981 	bl	4a0 <RCC_PCLK1Config>
  RCC_HCLKConfig(RCC_SYSCLK_Div1);
     19e:	f04f 0000 	mov.w	r0, #0
     1a2:	f000 f95b 	bl	45c <RCC_HCLKConfig>
  // Flash 1 wait state 
  *(vu32 *)0x40022000 = 0x12;
     1a6:	f242 0300 	movw	r3, #8192	; 0x2000
     1aa:	f2c4 0302 	movt	r3, #16386	; 0x4002
     1ae:	f04f 0212 	mov.w	r2, #18
     1b2:	601a      	str	r2, [r3, #0]
  // 5. Clock system from PLL
  RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
     1b4:	f04f 0002 	mov.w	r0, #2
     1b8:	f000 f920 	bl	3fc <RCC_SYSCLKConfig>
}
     1bc:	46bd      	mov	sp, r7
     1be:	bd80      	pop	{r7, pc}

000001c0 <RCC_DeInit>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_DeInit(void)
{
     1c0:	b480      	push	{r7}
     1c2:	af00      	add	r7, sp, #0
  /* Disable APB2 Peripheral Reset */
  RCC->APB2RSTR = 0x00000000;
     1c4:	f241 0300 	movw	r3, #4096	; 0x1000
     1c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
     1cc:	f04f 0200 	mov.w	r2, #0
     1d0:	60da      	str	r2, [r3, #12]

  /* Disable APB1 Peripheral Reset */
  RCC->APB1RSTR = 0x00000000;
     1d2:	f241 0300 	movw	r3, #4096	; 0x1000
     1d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
     1da:	f04f 0200 	mov.w	r2, #0
     1de:	611a      	str	r2, [r3, #16]

  /* FLITF and SRAM Clock ON */
  RCC->AHBENR = 0x00000014;
     1e0:	f241 0300 	movw	r3, #4096	; 0x1000
     1e4:	f2c4 0302 	movt	r3, #16386	; 0x4002
     1e8:	f04f 0214 	mov.w	r2, #20
     1ec:	615a      	str	r2, [r3, #20]

  /* Disable APB2 Peripheral Clock */
  RCC->APB2ENR = 0x00000000;
     1ee:	f241 0300 	movw	r3, #4096	; 0x1000
     1f2:	f2c4 0302 	movt	r3, #16386	; 0x4002
     1f6:	f04f 0200 	mov.w	r2, #0
     1fa:	619a      	str	r2, [r3, #24]

  /* Disable APB1 Peripheral Clock */
  RCC->APB1ENR = 0x00000000;
     1fc:	f241 0300 	movw	r3, #4096	; 0x1000
     200:	f2c4 0302 	movt	r3, #16386	; 0x4002
     204:	f04f 0200 	mov.w	r2, #0
     208:	61da      	str	r2, [r3, #28]

  /* Set HSION bit */
  RCC->CR |= (u32)0x00000001;
     20a:	f241 0300 	movw	r3, #4096	; 0x1000
     20e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     212:	f241 0200 	movw	r2, #4096	; 0x1000
     216:	f2c4 0202 	movt	r2, #16386	; 0x4002
     21a:	6812      	ldr	r2, [r2, #0]
     21c:	f042 0201 	orr.w	r2, r2, #1
     220:	601a      	str	r2, [r3, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits*/
  RCC->CFGR &= 0xF8FF0000;
     222:	f241 0200 	movw	r2, #4096	; 0x1000
     226:	f2c4 0202 	movt	r2, #16386	; 0x4002
     22a:	f241 0300 	movw	r3, #4096	; 0x1000
     22e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     232:	6859      	ldr	r1, [r3, #4]
     234:	f240 0300 	movw	r3, #0
     238:	f6cf 03ff 	movt	r3, #63743	; 0xf8ff
     23c:	ea01 0303 	and.w	r3, r1, r3
     240:	6053      	str	r3, [r2, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFF;
     242:	f241 0300 	movw	r3, #4096	; 0x1000
     246:	f2c4 0302 	movt	r3, #16386	; 0x4002
     24a:	f241 0200 	movw	r2, #4096	; 0x1000
     24e:	f2c4 0202 	movt	r2, #16386	; 0x4002
     252:	6812      	ldr	r2, [r2, #0]
     254:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
     258:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     25c:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFF;
     25e:	f241 0300 	movw	r3, #4096	; 0x1000
     262:	f2c4 0302 	movt	r3, #16386	; 0x4002
     266:	f241 0200 	movw	r2, #4096	; 0x1000
     26a:	f2c4 0202 	movt	r2, #16386	; 0x4002
     26e:	6812      	ldr	r2, [r2, #0]
     270:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     274:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits */
  RCC->CFGR &= 0xFF80FFFF;
     276:	f241 0300 	movw	r3, #4096	; 0x1000
     27a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     27e:	f241 0200 	movw	r2, #4096	; 0x1000
     282:	f2c4 0202 	movt	r2, #16386	; 0x4002
     286:	6852      	ldr	r2, [r2, #4]
     288:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
     28c:	605a      	str	r2, [r3, #4]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
     28e:	f241 0300 	movw	r3, #4096	; 0x1000
     292:	f2c4 0302 	movt	r3, #16386	; 0x4002
     296:	f04f 0200 	mov.w	r2, #0
     29a:	609a      	str	r2, [r3, #8]
}
     29c:	46bd      	mov	sp, r7
     29e:	bc80      	pop	{r7}
     2a0:	4770      	bx	lr
     2a2:	bf00      	nop

000002a4 <RCC_HSEConfig>:
*                         clock
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_HSEConfig(u32 RCC_HSE)
{
     2a4:	b480      	push	{r7}
     2a6:	b083      	sub	sp, #12
     2a8:	af00      	add	r7, sp, #0
     2aa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
     2ac:	f241 0300 	movw	r3, #4096	; 0x1000
     2b0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     2b4:	f241 0200 	movw	r2, #4096	; 0x1000
     2b8:	f2c4 0202 	movt	r2, #16386	; 0x4002
     2bc:	6812      	ldr	r2, [r2, #0]
     2be:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     2c2:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
     2c4:	f241 0300 	movw	r3, #4096	; 0x1000
     2c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
     2cc:	f241 0200 	movw	r2, #4096	; 0x1000
     2d0:	f2c4 0202 	movt	r2, #16386	; 0x4002
     2d4:	6812      	ldr	r2, [r2, #0]
     2d6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     2da:	601a      	str	r2, [r3, #0]

  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
     2dc:	687b      	ldr	r3, [r7, #4]
     2de:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
     2e2:	d003      	beq.n	2ec <RCC_HSEConfig+0x48>
     2e4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
     2e8:	d00d      	beq.n	306 <RCC_HSEConfig+0x62>
     2ea:	e018      	b.n	31e <RCC_HSEConfig+0x7a>
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
     2ec:	f241 0300 	movw	r3, #4096	; 0x1000
     2f0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     2f4:	f241 0200 	movw	r2, #4096	; 0x1000
     2f8:	f2c4 0202 	movt	r2, #16386	; 0x4002
     2fc:	6812      	ldr	r2, [r2, #0]
     2fe:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
     302:	601a      	str	r2, [r3, #0]
      break;
     304:	e00b      	b.n	31e <RCC_HSEConfig+0x7a>
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
     306:	f241 0300 	movw	r3, #4096	; 0x1000
     30a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     30e:	f241 0200 	movw	r2, #4096	; 0x1000
     312:	f2c4 0202 	movt	r2, #16386	; 0x4002
     316:	6812      	ldr	r2, [r2, #0]
     318:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
     31c:	601a      	str	r2, [r3, #0]
      break;            
      
    default:
      break;      
  }
}
     31e:	f107 070c 	add.w	r7, r7, #12
     322:	46bd      	mov	sp, r7
     324:	bc80      	pop	{r7}
     326:	4770      	bx	lr

00000328 <RCC_AdjustHSICalibrationValue>:
*                    This parameter must be a number between 0 and 0x1F.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue)
{
     328:	b480      	push	{r7}
     32a:	b085      	sub	sp, #20
     32c:	af00      	add	r7, sp, #0
     32e:	4603      	mov	r3, r0
     330:	71fb      	strb	r3, [r7, #7]
  u32 tmpreg = 0;
     332:	f04f 0300 	mov.w	r3, #0
     336:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
     338:	f241 0300 	movw	r3, #4096	; 0x1000
     33c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     340:	681b      	ldr	r3, [r3, #0]
     342:	60fb      	str	r3, [r7, #12]

  /* Clear HSITRIM[7:3] bits */
  tmpreg &= CR_HSITRIM_Mask;
     344:	68fb      	ldr	r3, [r7, #12]
     346:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
     34a:	60fb      	str	r3, [r7, #12]

  /* Set the HSITRIM[7:3] bits according to HSICalibrationValue value */
  tmpreg |= (u32)HSICalibrationValue << 3;
     34c:	79fb      	ldrb	r3, [r7, #7]
     34e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     352:	68fa      	ldr	r2, [r7, #12]
     354:	ea42 0303 	orr.w	r3, r2, r3
     358:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CR = tmpreg;
     35a:	f241 0300 	movw	r3, #4096	; 0x1000
     35e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     362:	68fa      	ldr	r2, [r7, #12]
     364:	601a      	str	r2, [r3, #0]
}
     366:	f107 0714 	add.w	r7, r7, #20
     36a:	46bd      	mov	sp, r7
     36c:	bc80      	pop	{r7}
     36e:	4770      	bx	lr

00000370 <RCC_HSICmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_HSICmd(FunctionalState NewState)
{
     370:	b480      	push	{r7}
     372:	b083      	sub	sp, #12
     374:	af00      	add	r7, sp, #0
     376:	4603      	mov	r3, r0
     378:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_HSION_BB = (u32)NewState;
     37a:	f240 0300 	movw	r3, #0
     37e:	f2c4 2342 	movt	r3, #16962	; 0x4242
     382:	79fa      	ldrb	r2, [r7, #7]
     384:	601a      	str	r2, [r3, #0]
}
     386:	f107 070c 	add.w	r7, r7, #12
     38a:	46bd      	mov	sp, r7
     38c:	bc80      	pop	{r7}
     38e:	4770      	bx	lr

00000390 <RCC_PLLConfig>:
*                    This parameter can be RCC_PLLMul_x where x:[2,16]
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul)
{
     390:	b480      	push	{r7}
     392:	b085      	sub	sp, #20
     394:	af00      	add	r7, sp, #0
     396:	6078      	str	r0, [r7, #4]
     398:	6039      	str	r1, [r7, #0]
  u32 tmpreg = 0;
     39a:	f04f 0300 	mov.w	r3, #0
     39e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
     3a0:	f241 0300 	movw	r3, #4096	; 0x1000
     3a4:	f2c4 0302 	movt	r3, #16386	; 0x4002
     3a8:	685b      	ldr	r3, [r3, #4]
     3aa:	60fb      	str	r3, [r7, #12]

  /* Clear PLLSRC, PLLXTPRE and PLLMUL[21:18] bits */
  tmpreg &= CFGR_PLL_Mask;
     3ac:	68fb      	ldr	r3, [r7, #12]
     3ae:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
     3b2:	60fb      	str	r3, [r7, #12]

  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
     3b4:	687a      	ldr	r2, [r7, #4]
     3b6:	683b      	ldr	r3, [r7, #0]
     3b8:	ea42 0303 	orr.w	r3, r2, r3
     3bc:	68fa      	ldr	r2, [r7, #12]
     3be:	ea42 0303 	orr.w	r3, r2, r3
     3c2:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     3c4:	f241 0300 	movw	r3, #4096	; 0x1000
     3c8:	f2c4 0302 	movt	r3, #16386	; 0x4002
     3cc:	68fa      	ldr	r2, [r7, #12]
     3ce:	605a      	str	r2, [r3, #4]
}
     3d0:	f107 0714 	add.w	r7, r7, #20
     3d4:	46bd      	mov	sp, r7
     3d6:	bc80      	pop	{r7}
     3d8:	4770      	bx	lr
     3da:	bf00      	nop

000003dc <RCC_PLLCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_PLLCmd(FunctionalState NewState)
{
     3dc:	b480      	push	{r7}
     3de:	b083      	sub	sp, #12
     3e0:	af00      	add	r7, sp, #0
     3e2:	4603      	mov	r3, r0
     3e4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_PLLON_BB = (u32)NewState;
     3e6:	f240 0360 	movw	r3, #96	; 0x60
     3ea:	f2c4 2342 	movt	r3, #16962	; 0x4242
     3ee:	79fa      	ldrb	r2, [r7, #7]
     3f0:	601a      	str	r2, [r3, #0]
}
     3f2:	f107 070c 	add.w	r7, r7, #12
     3f6:	46bd      	mov	sp, r7
     3f8:	bc80      	pop	{r7}
     3fa:	4770      	bx	lr

000003fc <RCC_SYSCLKConfig>:
*                       - RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_SYSCLKConfig(u32 RCC_SYSCLKSource)
{
     3fc:	b480      	push	{r7}
     3fe:	b085      	sub	sp, #20
     400:	af00      	add	r7, sp, #0
     402:	6078      	str	r0, [r7, #4]
  u32 tmpreg = 0;
     404:	f04f 0300 	mov.w	r3, #0
     408:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
     40a:	f241 0300 	movw	r3, #4096	; 0x1000
     40e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     412:	685b      	ldr	r3, [r3, #4]
     414:	60fb      	str	r3, [r7, #12]

  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
     416:	68fb      	ldr	r3, [r7, #12]
     418:	f023 0303 	bic.w	r3, r3, #3
     41c:	60fb      	str	r3, [r7, #12]

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
     41e:	68fa      	ldr	r2, [r7, #12]
     420:	687b      	ldr	r3, [r7, #4]
     422:	ea42 0303 	orr.w	r3, r2, r3
     426:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     428:	f241 0300 	movw	r3, #4096	; 0x1000
     42c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     430:	68fa      	ldr	r2, [r7, #12]
     432:	605a      	str	r2, [r3, #4]
}
     434:	f107 0714 	add.w	r7, r7, #20
     438:	46bd      	mov	sp, r7
     43a:	bc80      	pop	{r7}
     43c:	4770      	bx	lr
     43e:	bf00      	nop

00000440 <RCC_GetSYSCLKSource>:
*                       - 0x00: HSI used as system clock
*                       - 0x04: HSE used as system clock
*                       - 0x08: PLL used as system clock
*******************************************************************************/
u8 RCC_GetSYSCLKSource(void)
{
     440:	b480      	push	{r7}
     442:	af00      	add	r7, sp, #0
  return ((u8)(RCC->CFGR & CFGR_SWS_Mask));
     444:	f241 0300 	movw	r3, #4096	; 0x1000
     448:	f2c4 0302 	movt	r3, #16386	; 0x4002
     44c:	685b      	ldr	r3, [r3, #4]
     44e:	b2db      	uxtb	r3, r3
     450:	f003 030c 	and.w	r3, r3, #12
}
     454:	4618      	mov	r0, r3
     456:	46bd      	mov	sp, r7
     458:	bc80      	pop	{r7}
     45a:	4770      	bx	lr

0000045c <RCC_HCLKConfig>:
*                       - RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_HCLKConfig(u32 RCC_HCLK)
{
     45c:	b480      	push	{r7}
     45e:	b085      	sub	sp, #20
     460:	af00      	add	r7, sp, #0
     462:	6078      	str	r0, [r7, #4]
  u32 tmpreg = 0;
     464:	f04f 0300 	mov.w	r3, #0
     468:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_HCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
     46a:	f241 0300 	movw	r3, #4096	; 0x1000
     46e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     472:	685b      	ldr	r3, [r3, #4]
     474:	60fb      	str	r3, [r7, #12]

  /* Clear HPRE[7:4] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
     476:	68fb      	ldr	r3, [r7, #12]
     478:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
     47c:	60fb      	str	r3, [r7, #12]

  /* Set HPRE[7:4] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
     47e:	68fa      	ldr	r2, [r7, #12]
     480:	687b      	ldr	r3, [r7, #4]
     482:	ea42 0303 	orr.w	r3, r2, r3
     486:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     488:	f241 0300 	movw	r3, #4096	; 0x1000
     48c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     490:	68fa      	ldr	r2, [r7, #12]
     492:	605a      	str	r2, [r3, #4]
}
     494:	f107 0714 	add.w	r7, r7, #20
     498:	46bd      	mov	sp, r7
     49a:	bc80      	pop	{r7}
     49c:	4770      	bx	lr
     49e:	bf00      	nop

000004a0 <RCC_PCLK1Config>:
*                       - RCC_HCLK_Div16: APB1 clock = HCLK/16
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_PCLK1Config(u32 RCC_PCLK1)
{
     4a0:	b480      	push	{r7}
     4a2:	b085      	sub	sp, #20
     4a4:	af00      	add	r7, sp, #0
     4a6:	6078      	str	r0, [r7, #4]
  u32 tmpreg = 0;
     4a8:	f04f 0300 	mov.w	r3, #0
     4ac:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_PCLK(RCC_PCLK1));

  tmpreg = RCC->CFGR;
     4ae:	f241 0300 	movw	r3, #4096	; 0x1000
     4b2:	f2c4 0302 	movt	r3, #16386	; 0x4002
     4b6:	685b      	ldr	r3, [r3, #4]
     4b8:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE1[10:8] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
     4ba:	68fb      	ldr	r3, [r7, #12]
     4bc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
     4c0:	60fb      	str	r3, [r7, #12]

  /* Set PPRE1[10:8] bits according to RCC_PCLK1 value */
  tmpreg |= RCC_PCLK1;
     4c2:	68fa      	ldr	r2, [r7, #12]
     4c4:	687b      	ldr	r3, [r7, #4]
     4c6:	ea42 0303 	orr.w	r3, r2, r3
     4ca:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     4cc:	f241 0300 	movw	r3, #4096	; 0x1000
     4d0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     4d4:	68fa      	ldr	r2, [r7, #12]
     4d6:	605a      	str	r2, [r3, #4]
}
     4d8:	f107 0714 	add.w	r7, r7, #20
     4dc:	46bd      	mov	sp, r7
     4de:	bc80      	pop	{r7}
     4e0:	4770      	bx	lr
     4e2:	bf00      	nop

000004e4 <RCC_PCLK2Config>:
*                       - RCC_HCLK_Div16: APB2 clock = HCLK/16
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_PCLK2Config(u32 RCC_PCLK2)
{
     4e4:	b480      	push	{r7}
     4e6:	b085      	sub	sp, #20
     4e8:	af00      	add	r7, sp, #0
     4ea:	6078      	str	r0, [r7, #4]
  u32 tmpreg = 0;
     4ec:	f04f 0300 	mov.w	r3, #0
     4f0:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_PCLK(RCC_PCLK2));

  tmpreg = RCC->CFGR;
     4f2:	f241 0300 	movw	r3, #4096	; 0x1000
     4f6:	f2c4 0302 	movt	r3, #16386	; 0x4002
     4fa:	685b      	ldr	r3, [r3, #4]
     4fc:	60fb      	str	r3, [r7, #12]

  /* Clear PPRE2[13:11] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
     4fe:	68fb      	ldr	r3, [r7, #12]
     500:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
     504:	60fb      	str	r3, [r7, #12]

  /* Set PPRE2[13:11] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2 << 3;
     506:	687b      	ldr	r3, [r7, #4]
     508:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     50c:	68fa      	ldr	r2, [r7, #12]
     50e:	ea42 0303 	orr.w	r3, r2, r3
     512:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     514:	f241 0300 	movw	r3, #4096	; 0x1000
     518:	f2c4 0302 	movt	r3, #16386	; 0x4002
     51c:	68fa      	ldr	r2, [r7, #12]
     51e:	605a      	str	r2, [r3, #4]
}
     520:	f107 0714 	add.w	r7, r7, #20
     524:	46bd      	mov	sp, r7
     526:	bc80      	pop	{r7}
     528:	4770      	bx	lr
     52a:	bf00      	nop

0000052c <RCC_ITConfig>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_ITConfig(u8 RCC_IT, FunctionalState NewState)
{
     52c:	b480      	push	{r7}
     52e:	b083      	sub	sp, #12
     530:	af00      	add	r7, sp, #0
     532:	4602      	mov	r2, r0
     534:	460b      	mov	r3, r1
     536:	71fa      	strb	r2, [r7, #7]
     538:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert(IS_RCC_IT(RCC_IT));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     53a:	79bb      	ldrb	r3, [r7, #6]
     53c:	2b00      	cmp	r3, #0
     53e:	d00f      	beq.n	560 <RCC_ITConfig+0x34>
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to enable the selected interrupts */
    *(vu8 *) 0x40021009 |= RCC_IT;
     540:	f241 0309 	movw	r3, #4105	; 0x1009
     544:	f2c4 0302 	movt	r3, #16386	; 0x4002
     548:	f241 0209 	movw	r2, #4105	; 0x1009
     54c:	f2c4 0202 	movt	r2, #16386	; 0x4002
     550:	7812      	ldrb	r2, [r2, #0]
     552:	b2d1      	uxtb	r1, r2
     554:	79fa      	ldrb	r2, [r7, #7]
     556:	ea41 0202 	orr.w	r2, r1, r2
     55a:	b2d2      	uxtb	r2, r2
     55c:	701a      	strb	r2, [r3, #0]
     55e:	e011      	b.n	584 <RCC_ITConfig+0x58>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[12:8] bits to disable the selected interrupts */
    *(vu8 *) 0x40021009 &= ~(u32)RCC_IT;
     560:	f241 0309 	movw	r3, #4105	; 0x1009
     564:	f2c4 0302 	movt	r3, #16386	; 0x4002
     568:	f241 0209 	movw	r2, #4105	; 0x1009
     56c:	f2c4 0202 	movt	r2, #16386	; 0x4002
     570:	7812      	ldrb	r2, [r2, #0]
     572:	b2d1      	uxtb	r1, r2
     574:	79fa      	ldrb	r2, [r7, #7]
     576:	ea6f 0202 	mvn.w	r2, r2
     57a:	b2d2      	uxtb	r2, r2
     57c:	ea01 0202 	and.w	r2, r1, r2
     580:	b2d2      	uxtb	r2, r2
     582:	701a      	strb	r2, [r3, #0]
  }
}
     584:	f107 070c 	add.w	r7, r7, #12
     588:	46bd      	mov	sp, r7
     58a:	bc80      	pop	{r7}
     58c:	4770      	bx	lr
     58e:	bf00      	nop

00000590 <RCC_USBCLKConfig>:
*                         clock source
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_USBCLKConfig(u32 RCC_USBCLKSource)
{
     590:	b480      	push	{r7}
     592:	b083      	sub	sp, #12
     594:	af00      	add	r7, sp, #0
     596:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(vu32 *) CFGR_USBPRE_BB = RCC_USBCLKSource;
     598:	f240 03d8 	movw	r3, #216	; 0xd8
     59c:	f2c4 2342 	movt	r3, #16962	; 0x4242
     5a0:	687a      	ldr	r2, [r7, #4]
     5a2:	601a      	str	r2, [r3, #0]
}
     5a4:	f107 070c 	add.w	r7, r7, #12
     5a8:	46bd      	mov	sp, r7
     5aa:	bc80      	pop	{r7}
     5ac:	4770      	bx	lr
     5ae:	bf00      	nop

000005b0 <RCC_ADCCLKConfig>:
*                       - RCC_PCLK2_Div8: ADC clock = PCLK2/8
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_ADCCLKConfig(u32 RCC_ADCCLK)
{
     5b0:	b480      	push	{r7}
     5b2:	b085      	sub	sp, #20
     5b4:	af00      	add	r7, sp, #0
     5b6:	6078      	str	r0, [r7, #4]
  u32 tmpreg = 0;
     5b8:	f04f 0300 	mov.w	r3, #0
     5bc:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_RCC_ADCCLK(RCC_ADCCLK));

  tmpreg = RCC->CFGR;
     5be:	f241 0300 	movw	r3, #4096	; 0x1000
     5c2:	f2c4 0302 	movt	r3, #16386	; 0x4002
     5c6:	685b      	ldr	r3, [r3, #4]
     5c8:	60fb      	str	r3, [r7, #12]

  /* Clear ADCPRE[15:14] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
     5ca:	68fb      	ldr	r3, [r7, #12]
     5cc:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
     5d0:	60fb      	str	r3, [r7, #12]

  /* Set ADCPRE[15:14] bits according to RCC_ADCCLK value */
  tmpreg |= RCC_ADCCLK;
     5d2:	68fa      	ldr	r2, [r7, #12]
     5d4:	687b      	ldr	r3, [r7, #4]
     5d6:	ea42 0303 	orr.w	r3, r2, r3
     5da:	60fb      	str	r3, [r7, #12]

  /* Store the new value */
  RCC->CFGR = tmpreg;
     5dc:	f241 0300 	movw	r3, #4096	; 0x1000
     5e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     5e4:	68fa      	ldr	r2, [r7, #12]
     5e6:	605a      	str	r2, [r3, #4]
}
     5e8:	f107 0714 	add.w	r7, r7, #20
     5ec:	46bd      	mov	sp, r7
     5ee:	bc80      	pop	{r7}
     5f0:	4770      	bx	lr
     5f2:	bf00      	nop

000005f4 <RCC_LSEConfig>:
*                         clock
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_LSEConfig(u32 RCC_LSE)
{
     5f4:	b480      	push	{r7}
     5f6:	b083      	sub	sp, #12
     5f8:	af00      	add	r7, sp, #0
     5fa:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;
     5fc:	f241 0320 	movw	r3, #4128	; 0x1020
     600:	f2c4 0302 	movt	r3, #16386	; 0x4002
     604:	f04f 0200 	mov.w	r2, #0
     608:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(vu8 *) BDCR_BASE = RCC_LSE_OFF;
     60a:	f241 0320 	movw	r3, #4128	; 0x1020
     60e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     612:	f04f 0200 	mov.w	r2, #0
     616:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
     618:	687b      	ldr	r3, [r7, #4]
     61a:	2b01      	cmp	r3, #1
     61c:	d002      	beq.n	624 <RCC_LSEConfig+0x30>
     61e:	2b04      	cmp	r3, #4
     620:	d008      	beq.n	634 <RCC_LSEConfig+0x40>
     622:	e00e      	b.n	642 <RCC_LSEConfig+0x4e>
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(vu8 *) BDCR_BASE = RCC_LSE_ON;
     624:	f241 0320 	movw	r3, #4128	; 0x1020
     628:	f2c4 0302 	movt	r3, #16386	; 0x4002
     62c:	f04f 0201 	mov.w	r2, #1
     630:	701a      	strb	r2, [r3, #0]
      break;
     632:	e006      	b.n	642 <RCC_LSEConfig+0x4e>
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(vu8 *) BDCR_BASE = RCC_LSE_Bypass | RCC_LSE_ON;
     634:	f241 0320 	movw	r3, #4128	; 0x1020
     638:	f2c4 0302 	movt	r3, #16386	; 0x4002
     63c:	f04f 0205 	mov.w	r2, #5
     640:	701a      	strb	r2, [r3, #0]
      break;            
      
    default:
      break;      
  }
}
     642:	f107 070c 	add.w	r7, r7, #12
     646:	46bd      	mov	sp, r7
     648:	bc80      	pop	{r7}
     64a:	4770      	bx	lr

0000064c <RCC_LSICmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_LSICmd(FunctionalState NewState)
{
     64c:	b480      	push	{r7}
     64e:	b083      	sub	sp, #12
     650:	af00      	add	r7, sp, #0
     652:	4603      	mov	r3, r0
     654:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CSR_LSION_BB = (u32)NewState;
     656:	f240 4380 	movw	r3, #1152	; 0x480
     65a:	f2c4 2342 	movt	r3, #16962	; 0x4242
     65e:	79fa      	ldrb	r2, [r7, #7]
     660:	601a      	str	r2, [r3, #0]
}
     662:	f107 070c 	add.w	r7, r7, #12
     666:	46bd      	mov	sp, r7
     668:	bc80      	pop	{r7}
     66a:	4770      	bx	lr

0000066c <RCC_RTCCLKConfig>:
*                         by 128 used as RTC clock
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_RTCCLKConfig(u32 RCC_RTCCLKSource)
{
     66c:	b480      	push	{r7}
     66e:	b083      	sub	sp, #12
     670:	af00      	add	r7, sp, #0
     672:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
     674:	f241 0300 	movw	r3, #4096	; 0x1000
     678:	f2c4 0302 	movt	r3, #16386	; 0x4002
     67c:	f241 0200 	movw	r2, #4096	; 0x1000
     680:	f2c4 0202 	movt	r2, #16386	; 0x4002
     684:	6a11      	ldr	r1, [r2, #32]
     686:	687a      	ldr	r2, [r7, #4]
     688:	ea41 0202 	orr.w	r2, r1, r2
     68c:	621a      	str	r2, [r3, #32]
}
     68e:	f107 070c 	add.w	r7, r7, #12
     692:	46bd      	mov	sp, r7
     694:	bc80      	pop	{r7}
     696:	4770      	bx	lr

00000698 <RCC_RTCCLKCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_RTCCLKCmd(FunctionalState NewState)
{
     698:	b480      	push	{r7}
     69a:	b083      	sub	sp, #12
     69c:	af00      	add	r7, sp, #0
     69e:	4603      	mov	r3, r0
     6a0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_RTCEN_BB = (u32)NewState;
     6a2:	f240 433c 	movw	r3, #1084	; 0x43c
     6a6:	f2c4 2342 	movt	r3, #16962	; 0x4242
     6aa:	79fa      	ldrb	r2, [r7, #7]
     6ac:	601a      	str	r2, [r3, #0]
}
     6ae:	f107 070c 	add.w	r7, r7, #12
     6b2:	46bd      	mov	sp, r7
     6b4:	bc80      	pop	{r7}
     6b6:	4770      	bx	lr

000006b8 <RCC_GetClocksFreq>:
*                    will hold the clocks frequencies.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
     6b8:	b480      	push	{r7}
     6ba:	b087      	sub	sp, #28
     6bc:	af00      	add	r7, sp, #0
     6be:	6078      	str	r0, [r7, #4]
  u32 tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
     6c0:	f04f 0300 	mov.w	r3, #0
     6c4:	60bb      	str	r3, [r7, #8]
     6c6:	f04f 0300 	mov.w	r3, #0
     6ca:	60fb      	str	r3, [r7, #12]
     6cc:	f04f 0300 	mov.w	r3, #0
     6d0:	613b      	str	r3, [r7, #16]
     6d2:	f04f 0300 	mov.w	r3, #0
     6d6:	617b      	str	r3, [r7, #20]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
     6d8:	f241 0300 	movw	r3, #4096	; 0x1000
     6dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
     6e0:	685b      	ldr	r3, [r3, #4]
     6e2:	f003 030c 	and.w	r3, r3, #12
     6e6:	60bb      	str	r3, [r7, #8]

  switch (tmp)
     6e8:	68bb      	ldr	r3, [r7, #8]
     6ea:	2b04      	cmp	r3, #4
     6ec:	d00a      	beq.n	704 <RCC_GetClocksFreq+0x4c>
     6ee:	2b08      	cmp	r3, #8
     6f0:	d00f      	beq.n	712 <RCC_GetClocksFreq+0x5a>
     6f2:	2b00      	cmp	r3, #0
     6f4:	d14d      	bne.n	792 <RCC_GetClocksFreq+0xda>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
     6f6:	687a      	ldr	r2, [r7, #4]
     6f8:	f241 2300 	movw	r3, #4608	; 0x1200
     6fc:	f2c0 037a 	movt	r3, #122	; 0x7a
     700:	6013      	str	r3, [r2, #0]
      break;
     702:	e04c      	b.n	79e <RCC_GetClocksFreq+0xe6>

    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
     704:	687a      	ldr	r2, [r7, #4]
     706:	f241 2300 	movw	r3, #4608	; 0x1200
     70a:	f2c0 037a 	movt	r3, #122	; 0x7a
     70e:	6013      	str	r3, [r2, #0]
      break;
     710:	e045      	b.n	79e <RCC_GetClocksFreq+0xe6>

    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
     712:	f241 0300 	movw	r3, #4096	; 0x1000
     716:	f2c4 0302 	movt	r3, #16386	; 0x4002
     71a:	685b      	ldr	r3, [r3, #4]
     71c:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
     720:	60fb      	str	r3, [r7, #12]
      pllmull = ( pllmull >> 18) + 2;
     722:	68fb      	ldr	r3, [r7, #12]
     724:	ea4f 4393 	mov.w	r3, r3, lsr #18
     728:	f103 0302 	add.w	r3, r3, #2
     72c:	60fb      	str	r3, [r7, #12]

      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
     72e:	f241 0300 	movw	r3, #4096	; 0x1000
     732:	f2c4 0302 	movt	r3, #16386	; 0x4002
     736:	685b      	ldr	r3, [r3, #4]
     738:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
     73c:	613b      	str	r3, [r7, #16]

      if (pllsource == 0x00)
     73e:	693b      	ldr	r3, [r7, #16]
     740:	2b00      	cmp	r3, #0
     742:	d109      	bne.n	758 <RCC_GetClocksFreq+0xa0>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
     744:	68fa      	ldr	r2, [r7, #12]
     746:	f640 1300 	movw	r3, #2304	; 0x900
     74a:	f2c0 033d 	movt	r3, #61	; 0x3d
     74e:	fb03 f202 	mul.w	r2, r3, r2
     752:	687b      	ldr	r3, [r7, #4]
     754:	601a      	str	r2, [r3, #0]
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
        }
      }
      break;
     756:	e022      	b.n	79e <RCC_GetClocksFreq+0xe6>
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
      }
      else
      {/* HSE selected as PLL clock entry */

        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (u32)RESET)
     758:	f241 0300 	movw	r3, #4096	; 0x1000
     75c:	f2c4 0302 	movt	r3, #16386	; 0x4002
     760:	685b      	ldr	r3, [r3, #4]
     762:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
     766:	2b00      	cmp	r3, #0
     768:	d009      	beq.n	77e <RCC_GetClocksFreq+0xc6>
        {/* HSE oscillator clock divided by 2 */

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
     76a:	68fa      	ldr	r2, [r7, #12]
     76c:	f640 1300 	movw	r3, #2304	; 0x900
     770:	f2c0 033d 	movt	r3, #61	; 0x3d
     774:	fb03 f202 	mul.w	r2, r3, r2
     778:	687b      	ldr	r3, [r7, #4]
     77a:	601a      	str	r2, [r3, #0]
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
        }
      }
      break;
     77c:	e00f      	b.n	79e <RCC_GetClocksFreq+0xe6>

          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
        }
        else
        {
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
     77e:	68fa      	ldr	r2, [r7, #12]
     780:	f241 2300 	movw	r3, #4608	; 0x1200
     784:	f2c0 037a 	movt	r3, #122	; 0x7a
     788:	fb03 f202 	mul.w	r2, r3, r2
     78c:	687b      	ldr	r3, [r7, #4]
     78e:	601a      	str	r2, [r3, #0]
        }
      }
      break;
     790:	e005      	b.n	79e <RCC_GetClocksFreq+0xe6>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
     792:	687a      	ldr	r2, [r7, #4]
     794:	f241 2300 	movw	r3, #4608	; 0x1200
     798:	f2c0 037a 	movt	r3, #122	; 0x7a
     79c:	6013      	str	r3, [r2, #0]
      break;
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
     79e:	f241 0300 	movw	r3, #4096	; 0x1000
     7a2:	f2c4 0302 	movt	r3, #16386	; 0x4002
     7a6:	685b      	ldr	r3, [r3, #4]
     7a8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     7ac:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 4;
     7ae:	68bb      	ldr	r3, [r7, #8]
     7b0:	ea4f 1313 	mov.w	r3, r3, lsr #4
     7b4:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
     7b6:	68ba      	ldr	r2, [r7, #8]
     7b8:	f241 13dc 	movw	r3, #4572	; 0x11dc
     7bc:	f2c0 0300 	movt	r3, #0
     7c0:	5c9b      	ldrb	r3, [r3, r2]
     7c2:	617b      	str	r3, [r7, #20]

  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
     7c4:	687b      	ldr	r3, [r7, #4]
     7c6:	681a      	ldr	r2, [r3, #0]
     7c8:	697b      	ldr	r3, [r7, #20]
     7ca:	fa22 f203 	lsr.w	r2, r2, r3
     7ce:	687b      	ldr	r3, [r7, #4]
     7d0:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
     7d2:	f241 0300 	movw	r3, #4096	; 0x1000
     7d6:	f2c4 0302 	movt	r3, #16386	; 0x4002
     7da:	685b      	ldr	r3, [r3, #4]
     7dc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
     7e0:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 8;
     7e2:	68bb      	ldr	r3, [r7, #8]
     7e4:	ea4f 2313 	mov.w	r3, r3, lsr #8
     7e8:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
     7ea:	68ba      	ldr	r2, [r7, #8]
     7ec:	f241 13dc 	movw	r3, #4572	; 0x11dc
     7f0:	f2c0 0300 	movt	r3, #0
     7f4:	5c9b      	ldrb	r3, [r3, r2]
     7f6:	617b      	str	r3, [r7, #20]

  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
     7f8:	687b      	ldr	r3, [r7, #4]
     7fa:	685a      	ldr	r2, [r3, #4]
     7fc:	697b      	ldr	r3, [r7, #20]
     7fe:	fa22 f203 	lsr.w	r2, r2, r3
     802:	687b      	ldr	r3, [r7, #4]
     804:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
     806:	f241 0300 	movw	r3, #4096	; 0x1000
     80a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     80e:	685b      	ldr	r3, [r3, #4]
     810:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
     814:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 11;
     816:	68bb      	ldr	r3, [r7, #8]
     818:	ea4f 23d3 	mov.w	r3, r3, lsr #11
     81c:	60bb      	str	r3, [r7, #8]
  presc = APBAHBPrescTable[tmp];
     81e:	68ba      	ldr	r2, [r7, #8]
     820:	f241 13dc 	movw	r3, #4572	; 0x11dc
     824:	f2c0 0300 	movt	r3, #0
     828:	5c9b      	ldrb	r3, [r3, r2]
     82a:	617b      	str	r3, [r7, #20]

  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
     82c:	687b      	ldr	r3, [r7, #4]
     82e:	685a      	ldr	r2, [r3, #4]
     830:	697b      	ldr	r3, [r7, #20]
     832:	fa22 f203 	lsr.w	r2, r2, r3
     836:	687b      	ldr	r3, [r7, #4]
     838:	60da      	str	r2, [r3, #12]

  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
     83a:	f241 0300 	movw	r3, #4096	; 0x1000
     83e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     842:	685b      	ldr	r3, [r3, #4]
     844:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
     848:	60bb      	str	r3, [r7, #8]
  tmp = tmp >> 14;
     84a:	68bb      	ldr	r3, [r7, #8]
     84c:	ea4f 3393 	mov.w	r3, r3, lsr #14
     850:	60bb      	str	r3, [r7, #8]
  presc = ADCPrescTable[tmp];
     852:	68ba      	ldr	r2, [r7, #8]
     854:	f241 13ec 	movw	r3, #4588	; 0x11ec
     858:	f2c0 0300 	movt	r3, #0
     85c:	5c9b      	ldrb	r3, [r3, r2]
     85e:	617b      	str	r3, [r7, #20]

  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency ; // /presc;
     860:	687b      	ldr	r3, [r7, #4]
     862:	68da      	ldr	r2, [r3, #12]
     864:	687b      	ldr	r3, [r7, #4]
     866:	611a      	str	r2, [r3, #16]
}
     868:	f107 071c 	add.w	r7, r7, #28
     86c:	46bd      	mov	sp, r7
     86e:	bc80      	pop	{r7}
     870:	4770      	bx	lr
     872:	bf00      	nop

00000874 <RCC_AHBPeriphClockCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState)
{
     874:	b480      	push	{r7}
     876:	b083      	sub	sp, #12
     878:	af00      	add	r7, sp, #0
     87a:	6078      	str	r0, [r7, #4]
     87c:	460b      	mov	r3, r1
     87e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     880:	78fb      	ldrb	r3, [r7, #3]
     882:	2b00      	cmp	r3, #0
     884:	d00d      	beq.n	8a2 <RCC_AHBPeriphClockCmd+0x2e>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
     886:	f241 0300 	movw	r3, #4096	; 0x1000
     88a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     88e:	f241 0200 	movw	r2, #4096	; 0x1000
     892:	f2c4 0202 	movt	r2, #16386	; 0x4002
     896:	6951      	ldr	r1, [r2, #20]
     898:	687a      	ldr	r2, [r7, #4]
     89a:	ea41 0202 	orr.w	r2, r1, r2
     89e:	615a      	str	r2, [r3, #20]
     8a0:	e00e      	b.n	8c0 <RCC_AHBPeriphClockCmd+0x4c>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
     8a2:	f241 0300 	movw	r3, #4096	; 0x1000
     8a6:	f2c4 0302 	movt	r3, #16386	; 0x4002
     8aa:	f241 0200 	movw	r2, #4096	; 0x1000
     8ae:	f2c4 0202 	movt	r2, #16386	; 0x4002
     8b2:	6951      	ldr	r1, [r2, #20]
     8b4:	687a      	ldr	r2, [r7, #4]
     8b6:	ea6f 0202 	mvn.w	r2, r2
     8ba:	ea01 0202 	and.w	r2, r1, r2
     8be:	615a      	str	r2, [r3, #20]
  }
}
     8c0:	f107 070c 	add.w	r7, r7, #12
     8c4:	46bd      	mov	sp, r7
     8c6:	bc80      	pop	{r7}
     8c8:	4770      	bx	lr
     8ca:	bf00      	nop

000008cc <RCC_APB2PeriphClockCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState)
{
     8cc:	b480      	push	{r7}
     8ce:	b083      	sub	sp, #12
     8d0:	af00      	add	r7, sp, #0
     8d2:	6078      	str	r0, [r7, #4]
     8d4:	460b      	mov	r3, r1
     8d6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     8d8:	78fb      	ldrb	r3, [r7, #3]
     8da:	2b00      	cmp	r3, #0
     8dc:	d00d      	beq.n	8fa <RCC_APB2PeriphClockCmd+0x2e>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
     8de:	f241 0300 	movw	r3, #4096	; 0x1000
     8e2:	f2c4 0302 	movt	r3, #16386	; 0x4002
     8e6:	f241 0200 	movw	r2, #4096	; 0x1000
     8ea:	f2c4 0202 	movt	r2, #16386	; 0x4002
     8ee:	6991      	ldr	r1, [r2, #24]
     8f0:	687a      	ldr	r2, [r7, #4]
     8f2:	ea41 0202 	orr.w	r2, r1, r2
     8f6:	619a      	str	r2, [r3, #24]
     8f8:	e00e      	b.n	918 <RCC_APB2PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
     8fa:	f241 0300 	movw	r3, #4096	; 0x1000
     8fe:	f2c4 0302 	movt	r3, #16386	; 0x4002
     902:	f241 0200 	movw	r2, #4096	; 0x1000
     906:	f2c4 0202 	movt	r2, #16386	; 0x4002
     90a:	6991      	ldr	r1, [r2, #24]
     90c:	687a      	ldr	r2, [r7, #4]
     90e:	ea6f 0202 	mvn.w	r2, r2
     912:	ea01 0202 	and.w	r2, r1, r2
     916:	619a      	str	r2, [r3, #24]
  }
}
     918:	f107 070c 	add.w	r7, r7, #12
     91c:	46bd      	mov	sp, r7
     91e:	bc80      	pop	{r7}
     920:	4770      	bx	lr
     922:	bf00      	nop

00000924 <RCC_APB1PeriphClockCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState)
{
     924:	b480      	push	{r7}
     926:	b083      	sub	sp, #12
     928:	af00      	add	r7, sp, #0
     92a:	6078      	str	r0, [r7, #4]
     92c:	460b      	mov	r3, r1
     92e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     930:	78fb      	ldrb	r3, [r7, #3]
     932:	2b00      	cmp	r3, #0
     934:	d00d      	beq.n	952 <RCC_APB1PeriphClockCmd+0x2e>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
     936:	f241 0300 	movw	r3, #4096	; 0x1000
     93a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     93e:	f241 0200 	movw	r2, #4096	; 0x1000
     942:	f2c4 0202 	movt	r2, #16386	; 0x4002
     946:	69d1      	ldr	r1, [r2, #28]
     948:	687a      	ldr	r2, [r7, #4]
     94a:	ea41 0202 	orr.w	r2, r1, r2
     94e:	61da      	str	r2, [r3, #28]
     950:	e00e      	b.n	970 <RCC_APB1PeriphClockCmd+0x4c>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
     952:	f241 0300 	movw	r3, #4096	; 0x1000
     956:	f2c4 0302 	movt	r3, #16386	; 0x4002
     95a:	f241 0200 	movw	r2, #4096	; 0x1000
     95e:	f2c4 0202 	movt	r2, #16386	; 0x4002
     962:	69d1      	ldr	r1, [r2, #28]
     964:	687a      	ldr	r2, [r7, #4]
     966:	ea6f 0202 	mvn.w	r2, r2
     96a:	ea01 0202 	and.w	r2, r1, r2
     96e:	61da      	str	r2, [r3, #28]
  }
}
     970:	f107 070c 	add.w	r7, r7, #12
     974:	46bd      	mov	sp, r7
     976:	bc80      	pop	{r7}
     978:	4770      	bx	lr
     97a:	bf00      	nop

0000097c <RCC_APB2PeriphResetCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState)
{
     97c:	b480      	push	{r7}
     97e:	b083      	sub	sp, #12
     980:	af00      	add	r7, sp, #0
     982:	6078      	str	r0, [r7, #4]
     984:	460b      	mov	r3, r1
     986:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     988:	78fb      	ldrb	r3, [r7, #3]
     98a:	2b00      	cmp	r3, #0
     98c:	d00d      	beq.n	9aa <RCC_APB2PeriphResetCmd+0x2e>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
     98e:	f241 0300 	movw	r3, #4096	; 0x1000
     992:	f2c4 0302 	movt	r3, #16386	; 0x4002
     996:	f241 0200 	movw	r2, #4096	; 0x1000
     99a:	f2c4 0202 	movt	r2, #16386	; 0x4002
     99e:	68d1      	ldr	r1, [r2, #12]
     9a0:	687a      	ldr	r2, [r7, #4]
     9a2:	ea41 0202 	orr.w	r2, r1, r2
     9a6:	60da      	str	r2, [r3, #12]
     9a8:	e00e      	b.n	9c8 <RCC_APB2PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
     9aa:	f241 0300 	movw	r3, #4096	; 0x1000
     9ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
     9b2:	f241 0200 	movw	r2, #4096	; 0x1000
     9b6:	f2c4 0202 	movt	r2, #16386	; 0x4002
     9ba:	68d1      	ldr	r1, [r2, #12]
     9bc:	687a      	ldr	r2, [r7, #4]
     9be:	ea6f 0202 	mvn.w	r2, r2
     9c2:	ea01 0202 	and.w	r2, r1, r2
     9c6:	60da      	str	r2, [r3, #12]
  }
}
     9c8:	f107 070c 	add.w	r7, r7, #12
     9cc:	46bd      	mov	sp, r7
     9ce:	bc80      	pop	{r7}
     9d0:	4770      	bx	lr
     9d2:	bf00      	nop

000009d4 <RCC_APB1PeriphResetCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState)
{
     9d4:	b480      	push	{r7}
     9d6:	b083      	sub	sp, #12
     9d8:	af00      	add	r7, sp, #0
     9da:	6078      	str	r0, [r7, #4]
     9dc:	460b      	mov	r3, r1
     9de:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
     9e0:	78fb      	ldrb	r3, [r7, #3]
     9e2:	2b00      	cmp	r3, #0
     9e4:	d00d      	beq.n	a02 <RCC_APB1PeriphResetCmd+0x2e>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
     9e6:	f241 0300 	movw	r3, #4096	; 0x1000
     9ea:	f2c4 0302 	movt	r3, #16386	; 0x4002
     9ee:	f241 0200 	movw	r2, #4096	; 0x1000
     9f2:	f2c4 0202 	movt	r2, #16386	; 0x4002
     9f6:	6911      	ldr	r1, [r2, #16]
     9f8:	687a      	ldr	r2, [r7, #4]
     9fa:	ea41 0202 	orr.w	r2, r1, r2
     9fe:	611a      	str	r2, [r3, #16]
     a00:	e00e      	b.n	a20 <RCC_APB1PeriphResetCmd+0x4c>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
     a02:	f241 0300 	movw	r3, #4096	; 0x1000
     a06:	f2c4 0302 	movt	r3, #16386	; 0x4002
     a0a:	f241 0200 	movw	r2, #4096	; 0x1000
     a0e:	f2c4 0202 	movt	r2, #16386	; 0x4002
     a12:	6911      	ldr	r1, [r2, #16]
     a14:	687a      	ldr	r2, [r7, #4]
     a16:	ea6f 0202 	mvn.w	r2, r2
     a1a:	ea01 0202 	and.w	r2, r1, r2
     a1e:	611a      	str	r2, [r3, #16]
  }
}
     a20:	f107 070c 	add.w	r7, r7, #12
     a24:	46bd      	mov	sp, r7
     a26:	bc80      	pop	{r7}
     a28:	4770      	bx	lr
     a2a:	bf00      	nop

00000a2c <RCC_BackupResetCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_BackupResetCmd(FunctionalState NewState)
{
     a2c:	b480      	push	{r7}
     a2e:	b083      	sub	sp, #12
     a30:	af00      	add	r7, sp, #0
     a32:	4603      	mov	r3, r0
     a34:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) BDCR_BDRST_BB = (u32)NewState;
     a36:	f240 4340 	movw	r3, #1088	; 0x440
     a3a:	f2c4 2342 	movt	r3, #16962	; 0x4242
     a3e:	79fa      	ldrb	r2, [r7, #7]
     a40:	601a      	str	r2, [r3, #0]
}
     a42:	f107 070c 	add.w	r7, r7, #12
     a46:	46bd      	mov	sp, r7
     a48:	bc80      	pop	{r7}
     a4a:	4770      	bx	lr

00000a4c <RCC_ClockSecuritySystemCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
     a4c:	b480      	push	{r7}
     a4e:	b083      	sub	sp, #12
     a50:	af00      	add	r7, sp, #0
     a52:	4603      	mov	r3, r0
     a54:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));

  *(vu32 *) CR_CSSON_BB = (u32)NewState;
     a56:	f240 034c 	movw	r3, #76	; 0x4c
     a5a:	f2c4 2342 	movt	r3, #16962	; 0x4242
     a5e:	79fa      	ldrb	r2, [r7, #7]
     a60:	601a      	str	r2, [r3, #0]
}
     a62:	f107 070c 	add.w	r7, r7, #12
     a66:	46bd      	mov	sp, r7
     a68:	bc80      	pop	{r7}
     a6a:	4770      	bx	lr

00000a6c <RCC_MCOConfig>:
*                       - RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_MCOConfig(u8 RCC_MCO)
{
     a6c:	b480      	push	{r7}
     a6e:	b083      	sub	sp, #12
     a70:	af00      	add	r7, sp, #0
     a72:	4603      	mov	r3, r0
     a74:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO[26:24] bits to select the MCO source */
  *(vu8 *) 0x40021007 = RCC_MCO;
     a76:	f241 0307 	movw	r3, #4103	; 0x1007
     a7a:	f2c4 0302 	movt	r3, #16386	; 0x4002
     a7e:	79fa      	ldrb	r2, [r7, #7]
     a80:	701a      	strb	r2, [r3, #0]
}
     a82:	f107 070c 	add.w	r7, r7, #12
     a86:	46bd      	mov	sp, r7
     a88:	bc80      	pop	{r7}
     a8a:	4770      	bx	lr

00000a8c <RCC_GetFlagStatus>:
*                       - RCC_FLAG_LPWRRST: Low Power reset
* Output         : None
* Return         : The new state of RCC_FLAG (SET or RESET).
*******************************************************************************/
FlagStatus RCC_GetFlagStatus(u8 RCC_FLAG)
{
     a8c:	b480      	push	{r7}
     a8e:	b087      	sub	sp, #28
     a90:	af00      	add	r7, sp, #0
     a92:	4603      	mov	r3, r0
     a94:	71fb      	strb	r3, [r7, #7]
  u32 tmp = 0;
     a96:	f04f 0300 	mov.w	r3, #0
     a9a:	60fb      	str	r3, [r7, #12]
  u32 statusreg = 0;
     a9c:	f04f 0300 	mov.w	r3, #0
     aa0:	613b      	str	r3, [r7, #16]
  FlagStatus bitstatus = RESET;
     aa2:	f04f 0300 	mov.w	r3, #0
     aa6:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
     aa8:	79fb      	ldrb	r3, [r7, #7]
     aaa:	ea4f 1353 	mov.w	r3, r3, lsr #5
     aae:	b2db      	uxtb	r3, r3
     ab0:	60fb      	str	r3, [r7, #12]

  if (tmp == 1)               /* The flag to check is in CR register */
     ab2:	68fb      	ldr	r3, [r7, #12]
     ab4:	2b01      	cmp	r3, #1
     ab6:	d106      	bne.n	ac6 <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->CR;
     ab8:	f241 0300 	movw	r3, #4096	; 0x1000
     abc:	f2c4 0302 	movt	r3, #16386	; 0x4002
     ac0:	681b      	ldr	r3, [r3, #0]
     ac2:	613b      	str	r3, [r7, #16]
     ac4:	e00f      	b.n	ae6 <RCC_GetFlagStatus+0x5a>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
     ac6:	68fb      	ldr	r3, [r7, #12]
     ac8:	2b02      	cmp	r3, #2
     aca:	d106      	bne.n	ada <RCC_GetFlagStatus+0x4e>
  {
    statusreg = RCC->BDCR;
     acc:	f241 0300 	movw	r3, #4096	; 0x1000
     ad0:	f2c4 0302 	movt	r3, #16386	; 0x4002
     ad4:	6a1b      	ldr	r3, [r3, #32]
     ad6:	613b      	str	r3, [r7, #16]
     ad8:	e005      	b.n	ae6 <RCC_GetFlagStatus+0x5a>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
     ada:	f241 0300 	movw	r3, #4096	; 0x1000
     ade:	f2c4 0302 	movt	r3, #16386	; 0x4002
     ae2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     ae4:	613b      	str	r3, [r7, #16]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
     ae6:	79fb      	ldrb	r3, [r7, #7]
     ae8:	f003 031f 	and.w	r3, r3, #31
     aec:	60fb      	str	r3, [r7, #12]

  if ((statusreg & ((u32)1 << tmp)) != (u32)RESET)
     aee:	68fb      	ldr	r3, [r7, #12]
     af0:	693a      	ldr	r2, [r7, #16]
     af2:	fa22 f303 	lsr.w	r3, r2, r3
     af6:	f003 0301 	and.w	r3, r3, #1
     afa:	b2db      	uxtb	r3, r3
     afc:	2b00      	cmp	r3, #0
     afe:	d003      	beq.n	b08 <RCC_GetFlagStatus+0x7c>
  {
    bitstatus = SET;
     b00:	f04f 0301 	mov.w	r3, #1
     b04:	75fb      	strb	r3, [r7, #23]
     b06:	e002      	b.n	b0e <RCC_GetFlagStatus+0x82>
  }
  else
  {
    bitstatus = RESET;
     b08:	f04f 0300 	mov.w	r3, #0
     b0c:	75fb      	strb	r3, [r7, #23]
  }

  /* Return the flag status */
  return bitstatus;
     b0e:	7dfb      	ldrb	r3, [r7, #23]
}
     b10:	4618      	mov	r0, r3
     b12:	f107 071c 	add.w	r7, r7, #28
     b16:	46bd      	mov	sp, r7
     b18:	bc80      	pop	{r7}
     b1a:	4770      	bx	lr

00000b1c <RCC_ClearFlag>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_ClearFlag(void)
{
     b1c:	b480      	push	{r7}
     b1e:	af00      	add	r7, sp, #0
  /* Set RVMF bit to clear the reset flags */
  RCC->CSR |= CSR_RVMF_Set;
     b20:	f241 0300 	movw	r3, #4096	; 0x1000
     b24:	f2c4 0302 	movt	r3, #16386	; 0x4002
     b28:	f241 0200 	movw	r2, #4096	; 0x1000
     b2c:	f2c4 0202 	movt	r2, #16386	; 0x4002
     b30:	6a52      	ldr	r2, [r2, #36]	; 0x24
     b32:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     b36:	625a      	str	r2, [r3, #36]	; 0x24
}
     b38:	46bd      	mov	sp, r7
     b3a:	bc80      	pop	{r7}
     b3c:	4770      	bx	lr
     b3e:	bf00      	nop

00000b40 <RCC_GetITStatus>:
*                       - RCC_IT_CSS: Clock Security System interrupt
* Output         : None
* Return         : The new state of RCC_IT (SET or RESET).
*******************************************************************************/
ITStatus RCC_GetITStatus(u8 RCC_IT)
{
     b40:	b480      	push	{r7}
     b42:	b085      	sub	sp, #20
     b44:	af00      	add	r7, sp, #0
     b46:	4603      	mov	r3, r0
     b48:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
     b4a:	f04f 0300 	mov.w	r3, #0
     b4e:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (u32)RESET)
     b50:	f241 0300 	movw	r3, #4096	; 0x1000
     b54:	f2c4 0302 	movt	r3, #16386	; 0x4002
     b58:	689a      	ldr	r2, [r3, #8]
     b5a:	79fb      	ldrb	r3, [r7, #7]
     b5c:	ea02 0303 	and.w	r3, r2, r3
     b60:	2b00      	cmp	r3, #0
     b62:	d003      	beq.n	b6c <RCC_GetITStatus+0x2c>
  {
    bitstatus = SET;
     b64:	f04f 0301 	mov.w	r3, #1
     b68:	73fb      	strb	r3, [r7, #15]
     b6a:	e002      	b.n	b72 <RCC_GetITStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
     b6c:	f04f 0300 	mov.w	r3, #0
     b70:	73fb      	strb	r3, [r7, #15]
  }

  /* Return the RCC_IT status */
  return  bitstatus;
     b72:	7bfb      	ldrb	r3, [r7, #15]
}
     b74:	4618      	mov	r0, r3
     b76:	f107 0714 	add.w	r7, r7, #20
     b7a:	46bd      	mov	sp, r7
     b7c:	bc80      	pop	{r7}
     b7e:	4770      	bx	lr

00000b80 <RCC_ClearITPendingBit>:
*                       - RCC_IT_CSS: Clock Security System interrupt
* Output         : None
* Return         : None
*******************************************************************************/
void RCC_ClearITPendingBit(u8 RCC_IT)
{
     b80:	b480      	push	{r7}
     b82:	b083      	sub	sp, #12
     b84:	af00      	add	r7, sp, #0
     b86:	4603      	mov	r3, r0
     b88:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(vu8 *) 0x4002100A = RCC_IT;
     b8a:	f241 030a 	movw	r3, #4106	; 0x100a
     b8e:	f2c4 0302 	movt	r3, #16386	; 0x4002
     b92:	79fa      	ldrb	r2, [r7, #7]
     b94:	701a      	strb	r2, [r3, #0]
}
     b96:	f107 070c 	add.w	r7, r7, #12
     b9a:	46bd      	mov	sp, r7
     b9c:	bc80      	pop	{r7}
     b9e:	4770      	bx	lr

00000ba0 <GPIO_DeInit>:
* Input          : - GPIOx: where x can be (A..E) to select the GPIO peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
     ba0:	b580      	push	{r7, lr}
     ba2:	b082      	sub	sp, #8
     ba4:	af00      	add	r7, sp, #0
     ba6:	6078      	str	r0, [r7, #4]
  switch (*(u32*)&GPIOx)
     ba8:	f107 0304 	add.w	r3, r7, #4
     bac:	681b      	ldr	r3, [r3, #0]
     bae:	f241 0200 	movw	r2, #4096	; 0x1000
     bb2:	f2c4 0201 	movt	r2, #16385	; 0x4001
     bb6:	4293      	cmp	r3, r2
     bb8:	d039      	beq.n	c2e <GPIO_DeInit+0x8e>
     bba:	f241 0200 	movw	r2, #4096	; 0x1000
     bbe:	f2c4 0201 	movt	r2, #16385	; 0x4001
     bc2:	4293      	cmp	r3, r2
     bc4:	d80c      	bhi.n	be0 <GPIO_DeInit+0x40>
     bc6:	f640 0200 	movw	r2, #2048	; 0x800
     bca:	f2c4 0201 	movt	r2, #16385	; 0x4001
     bce:	4293      	cmp	r3, r2
     bd0:	d013      	beq.n	bfa <GPIO_DeInit+0x5a>
     bd2:	f640 4200 	movw	r2, #3072	; 0xc00
     bd6:	f2c4 0201 	movt	r2, #16385	; 0x4001
     bda:	4293      	cmp	r3, r2
     bdc:	d01a      	beq.n	c14 <GPIO_DeInit+0x74>
     bde:	e04c      	b.n	c7a <GPIO_DeInit+0xda>
     be0:	f241 4200 	movw	r2, #5120	; 0x1400
     be4:	f2c4 0201 	movt	r2, #16385	; 0x4001
     be8:	4293      	cmp	r3, r2
     bea:	d02d      	beq.n	c48 <GPIO_DeInit+0xa8>
     bec:	f641 0200 	movw	r2, #6144	; 0x1800
     bf0:	f2c4 0201 	movt	r2, #16385	; 0x4001
     bf4:	4293      	cmp	r3, r2
     bf6:	d034      	beq.n	c62 <GPIO_DeInit+0xc2>
     bf8:	e03f      	b.n	c7a <GPIO_DeInit+0xda>
  {
    case GPIOA_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
     bfa:	f04f 0004 	mov.w	r0, #4
     bfe:	f04f 0101 	mov.w	r1, #1
     c02:	f7ff febb 	bl	97c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
     c06:	f04f 0004 	mov.w	r0, #4
     c0a:	f04f 0100 	mov.w	r1, #0
     c0e:	f7ff feb5 	bl	97c <RCC_APB2PeriphResetCmd>
      break;
     c12:	e032      	b.n	c7a <GPIO_DeInit+0xda>

    case GPIOB_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
     c14:	f04f 0008 	mov.w	r0, #8
     c18:	f04f 0101 	mov.w	r1, #1
     c1c:	f7ff feae 	bl	97c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
     c20:	f04f 0008 	mov.w	r0, #8
     c24:	f04f 0100 	mov.w	r1, #0
     c28:	f7ff fea8 	bl	97c <RCC_APB2PeriphResetCmd>
      break;
     c2c:	e025      	b.n	c7a <GPIO_DeInit+0xda>

    case GPIOC_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
     c2e:	f04f 0010 	mov.w	r0, #16
     c32:	f04f 0101 	mov.w	r1, #1
     c36:	f7ff fea1 	bl	97c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
     c3a:	f04f 0010 	mov.w	r0, #16
     c3e:	f04f 0100 	mov.w	r1, #0
     c42:	f7ff fe9b 	bl	97c <RCC_APB2PeriphResetCmd>
      break;
     c46:	e018      	b.n	c7a <GPIO_DeInit+0xda>

    case GPIOD_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
     c48:	f04f 0020 	mov.w	r0, #32
     c4c:	f04f 0101 	mov.w	r1, #1
     c50:	f7ff fe94 	bl	97c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
     c54:	f04f 0020 	mov.w	r0, #32
     c58:	f04f 0100 	mov.w	r1, #0
     c5c:	f7ff fe8e 	bl	97c <RCC_APB2PeriphResetCmd>
      break;
     c60:	e00b      	b.n	c7a <GPIO_DeInit+0xda>
      
    case GPIOE_BASE:
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
     c62:	f04f 0040 	mov.w	r0, #64	; 0x40
     c66:	f04f 0101 	mov.w	r1, #1
     c6a:	f7ff fe87 	bl	97c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
     c6e:	f04f 0040 	mov.w	r0, #64	; 0x40
     c72:	f04f 0100 	mov.w	r1, #0
     c76:	f7ff fe81 	bl	97c <RCC_APB2PeriphResetCmd>
      break;            

    default:
      break;
  }
}
     c7a:	f107 0708 	add.w	r7, r7, #8
     c7e:	46bd      	mov	sp, r7
     c80:	bd80      	pop	{r7, pc}
     c82:	bf00      	nop

00000c84 <GPIO_AFIODeInit>:
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_AFIODeInit(void)
{
     c84:	b580      	push	{r7, lr}
     c86:	af00      	add	r7, sp, #0
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
     c88:	f04f 0001 	mov.w	r0, #1
     c8c:	f04f 0101 	mov.w	r1, #1
     c90:	f7ff fe74 	bl	97c <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
     c94:	f04f 0001 	mov.w	r0, #1
     c98:	f04f 0100 	mov.w	r1, #0
     c9c:	f7ff fe6e 	bl	97c <RCC_APB2PeriphResetCmd>
}
     ca0:	46bd      	mov	sp, r7
     ca2:	bd80      	pop	{r7, pc}

00000ca4 <GPIO_Init>:
*                    peripheral.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
     ca4:	b480      	push	{r7}
     ca6:	b089      	sub	sp, #36	; 0x24
     ca8:	af00      	add	r7, sp, #0
     caa:	6078      	str	r0, [r7, #4]
     cac:	6039      	str	r1, [r7, #0]
  u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
     cae:	f04f 0300 	mov.w	r3, #0
     cb2:	60bb      	str	r3, [r7, #8]
     cb4:	f04f 0300 	mov.w	r3, #0
     cb8:	60fb      	str	r3, [r7, #12]
     cba:	f04f 0300 	mov.w	r3, #0
     cbe:	613b      	str	r3, [r7, #16]
     cc0:	f04f 0300 	mov.w	r3, #0
     cc4:	617b      	str	r3, [r7, #20]
  u32 tmpreg = 0x00, pinmask = 0x00;
     cc6:	f04f 0300 	mov.w	r3, #0
     cca:	61bb      	str	r3, [r7, #24]
     ccc:	f04f 0300 	mov.w	r3, #0
     cd0:	61fb      	str	r3, [r7, #28]
  /* Check the parameters */
  assert(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
     cd2:	683b      	ldr	r3, [r7, #0]
     cd4:	78db      	ldrb	r3, [r3, #3]
     cd6:	f003 030f 	and.w	r3, r3, #15
     cda:	60bb      	str	r3, [r7, #8]

  if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
     cdc:	683b      	ldr	r3, [r7, #0]
     cde:	78db      	ldrb	r3, [r3, #3]
     ce0:	f003 0310 	and.w	r3, r3, #16
     ce4:	2b00      	cmp	r3, #0
     ce6:	d005      	beq.n	cf4 <GPIO_Init+0x50>
  { 
    /* Check the parameters */
    assert(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
     ce8:	683b      	ldr	r3, [r7, #0]
     cea:	789b      	ldrb	r3, [r3, #2]
     cec:	68ba      	ldr	r2, [r7, #8]
     cee:	ea42 0303 	orr.w	r3, r2, r3
     cf2:	60bb      	str	r3, [r7, #8]
  }

/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
     cf4:	683b      	ldr	r3, [r7, #0]
     cf6:	881b      	ldrh	r3, [r3, #0]
     cf8:	f003 03ff 	and.w	r3, r3, #255	; 0xff
     cfc:	2b00      	cmp	r3, #0
     cfe:	d053      	beq.n	da8 <GPIO_Init+0x104>
  {
    tmpreg = GPIOx->CRL;
     d00:	687b      	ldr	r3, [r7, #4]
     d02:	681b      	ldr	r3, [r3, #0]
     d04:	61bb      	str	r3, [r7, #24]

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     d06:	f04f 0300 	mov.w	r3, #0
     d0a:	613b      	str	r3, [r7, #16]
     d0c:	e043      	b.n	d96 <GPIO_Init+0xf2>
    {
      pos = ((u32)0x01) << pinpos;
     d0e:	693b      	ldr	r3, [r7, #16]
     d10:	f04f 0201 	mov.w	r2, #1
     d14:	fa02 f303 	lsl.w	r3, r2, r3
     d18:	617b      	str	r3, [r7, #20]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
     d1a:	683b      	ldr	r3, [r7, #0]
     d1c:	881b      	ldrh	r3, [r3, #0]
     d1e:	461a      	mov	r2, r3
     d20:	697b      	ldr	r3, [r7, #20]
     d22:	ea02 0303 	and.w	r3, r2, r3
     d26:	60fb      	str	r3, [r7, #12]

      if (currentpin == pos)
     d28:	68fa      	ldr	r2, [r7, #12]
     d2a:	697b      	ldr	r3, [r7, #20]
     d2c:	429a      	cmp	r2, r3
     d2e:	d12e      	bne.n	d8e <GPIO_Init+0xea>
      {
        pos = pinpos << 2;
     d30:	693b      	ldr	r3, [r7, #16]
     d32:	ea4f 0383 	mov.w	r3, r3, lsl #2
     d36:	617b      	str	r3, [r7, #20]
        /* Clear the corresponding low control register bits */
        pinmask = ((u32)0x0F) << pos;
     d38:	697b      	ldr	r3, [r7, #20]
     d3a:	f04f 020f 	mov.w	r2, #15
     d3e:	fa02 f303 	lsl.w	r3, r2, r3
     d42:	61fb      	str	r3, [r7, #28]
        tmpreg &= ~pinmask;
     d44:	69fb      	ldr	r3, [r7, #28]
     d46:	ea6f 0303 	mvn.w	r3, r3
     d4a:	69ba      	ldr	r2, [r7, #24]
     d4c:	ea02 0303 	and.w	r3, r2, r3
     d50:	61bb      	str	r3, [r7, #24]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
     d52:	697b      	ldr	r3, [r7, #20]
     d54:	68ba      	ldr	r2, [r7, #8]
     d56:	fa02 f303 	lsl.w	r3, r2, r3
     d5a:	69ba      	ldr	r2, [r7, #24]
     d5c:	ea42 0303 	orr.w	r3, r2, r3
     d60:	61bb      	str	r3, [r7, #24]

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
     d62:	683b      	ldr	r3, [r7, #0]
     d64:	78db      	ldrb	r3, [r3, #3]
     d66:	2b28      	cmp	r3, #40	; 0x28
     d68:	d106      	bne.n	d78 <GPIO_Init+0xd4>
        {
          GPIOx->BRR = (((u32)0x01) << pinpos);
     d6a:	693b      	ldr	r3, [r7, #16]
     d6c:	f04f 0201 	mov.w	r2, #1
     d70:	fa02 f203 	lsl.w	r2, r2, r3
     d74:	687b      	ldr	r3, [r7, #4]
     d76:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
     d78:	683b      	ldr	r3, [r7, #0]
     d7a:	78db      	ldrb	r3, [r3, #3]
     d7c:	2b48      	cmp	r3, #72	; 0x48
     d7e:	d106      	bne.n	d8e <GPIO_Init+0xea>
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
     d80:	693b      	ldr	r3, [r7, #16]
     d82:	f04f 0201 	mov.w	r2, #1
     d86:	fa02 f203 	lsl.w	r2, r2, r3
     d8a:	687b      	ldr	r3, [r7, #4]
     d8c:	611a      	str	r2, [r3, #16]
  /* Configure the eight low port pins */
  if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
  {
    tmpreg = GPIOx->CRL;

    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     d8e:	693b      	ldr	r3, [r7, #16]
     d90:	f103 0301 	add.w	r3, r3, #1
     d94:	613b      	str	r3, [r7, #16]
     d96:	693b      	ldr	r3, [r7, #16]
     d98:	2b07      	cmp	r3, #7
     d9a:	d9b8      	bls.n	d0e <GPIO_Init+0x6a>
        {
          GPIOx->BSRR = (((u32)0x01) << pinpos);
        }
      }
    }
    GPIOx->CRL = tmpreg;
     d9c:	687b      	ldr	r3, [r7, #4]
     d9e:	69ba      	ldr	r2, [r7, #24]
     da0:	601a      	str	r2, [r3, #0]
    tmpreg = 0;
     da2:	f04f 0300 	mov.w	r3, #0
     da6:	61bb      	str	r3, [r7, #24]
  }

/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
     da8:	683b      	ldr	r3, [r7, #0]
     daa:	881b      	ldrh	r3, [r3, #0]
     dac:	2bff      	cmp	r3, #255	; 0xff
     dae:	d956      	bls.n	e5e <GPIO_Init+0x1ba>
  {
    tmpreg = GPIOx->CRH;
     db0:	687b      	ldr	r3, [r7, #4]
     db2:	685b      	ldr	r3, [r3, #4]
     db4:	61bb      	str	r3, [r7, #24]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     db6:	f04f 0300 	mov.w	r3, #0
     dba:	613b      	str	r3, [r7, #16]
     dbc:	e049      	b.n	e52 <GPIO_Init+0x1ae>
    {
      pos = (((u32)0x01) << (pinpos + 0x08));
     dbe:	693b      	ldr	r3, [r7, #16]
     dc0:	f103 0308 	add.w	r3, r3, #8
     dc4:	f04f 0201 	mov.w	r2, #1
     dc8:	fa02 f303 	lsl.w	r3, r2, r3
     dcc:	617b      	str	r3, [r7, #20]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
     dce:	683b      	ldr	r3, [r7, #0]
     dd0:	881b      	ldrh	r3, [r3, #0]
     dd2:	461a      	mov	r2, r3
     dd4:	697b      	ldr	r3, [r7, #20]
     dd6:	ea02 0303 	and.w	r3, r2, r3
     dda:	60fb      	str	r3, [r7, #12]
      if (currentpin == pos)
     ddc:	68fa      	ldr	r2, [r7, #12]
     dde:	697b      	ldr	r3, [r7, #20]
     de0:	429a      	cmp	r2, r3
     de2:	d132      	bne.n	e4a <GPIO_Init+0x1a6>
      {
        pos = pinpos << 2;
     de4:	693b      	ldr	r3, [r7, #16]
     de6:	ea4f 0383 	mov.w	r3, r3, lsl #2
     dea:	617b      	str	r3, [r7, #20]
        /* Clear the corresponding high control register bits */
        pinmask = ((u32)0x0F) << pos;
     dec:	697b      	ldr	r3, [r7, #20]
     dee:	f04f 020f 	mov.w	r2, #15
     df2:	fa02 f303 	lsl.w	r3, r2, r3
     df6:	61fb      	str	r3, [r7, #28]
        tmpreg &= ~pinmask;
     df8:	69fb      	ldr	r3, [r7, #28]
     dfa:	ea6f 0303 	mvn.w	r3, r3
     dfe:	69ba      	ldr	r2, [r7, #24]
     e00:	ea02 0303 	and.w	r3, r2, r3
     e04:	61bb      	str	r3, [r7, #24]

        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
     e06:	697b      	ldr	r3, [r7, #20]
     e08:	68ba      	ldr	r2, [r7, #8]
     e0a:	fa02 f303 	lsl.w	r3, r2, r3
     e0e:	69ba      	ldr	r2, [r7, #24]
     e10:	ea42 0303 	orr.w	r3, r2, r3
     e14:	61bb      	str	r3, [r7, #24]

        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
     e16:	683b      	ldr	r3, [r7, #0]
     e18:	78db      	ldrb	r3, [r3, #3]
     e1a:	2b28      	cmp	r3, #40	; 0x28
     e1c:	d108      	bne.n	e30 <GPIO_Init+0x18c>
        {
          GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
     e1e:	693b      	ldr	r3, [r7, #16]
     e20:	f103 0308 	add.w	r3, r3, #8
     e24:	f04f 0201 	mov.w	r2, #1
     e28:	fa02 f203 	lsl.w	r2, r2, r3
     e2c:	687b      	ldr	r3, [r7, #4]
     e2e:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
     e30:	683b      	ldr	r3, [r7, #0]
     e32:	78db      	ldrb	r3, [r3, #3]
     e34:	2b48      	cmp	r3, #72	; 0x48
     e36:	d108      	bne.n	e4a <GPIO_Init+0x1a6>
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
     e38:	693b      	ldr	r3, [r7, #16]
     e3a:	f103 0308 	add.w	r3, r3, #8
     e3e:	f04f 0201 	mov.w	r2, #1
     e42:	fa02 f203 	lsl.w	r2, r2, r3
     e46:	687b      	ldr	r3, [r7, #4]
     e48:	611a      	str	r2, [r3, #16]
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
  {
    tmpreg = GPIOx->CRH;
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
     e4a:	693b      	ldr	r3, [r7, #16]
     e4c:	f103 0301 	add.w	r3, r3, #1
     e50:	613b      	str	r3, [r7, #16]
     e52:	693b      	ldr	r3, [r7, #16]
     e54:	2b07      	cmp	r3, #7
     e56:	d9b2      	bls.n	dbe <GPIO_Init+0x11a>
        {
          GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
        }
      }
    }
    GPIOx->CRH = tmpreg;
     e58:	687b      	ldr	r3, [r7, #4]
     e5a:	69ba      	ldr	r2, [r7, #24]
     e5c:	605a      	str	r2, [r3, #4]
  }
}
     e5e:	f107 0724 	add.w	r7, r7, #36	; 0x24
     e62:	46bd      	mov	sp, r7
     e64:	bc80      	pop	{r7}
     e66:	4770      	bx	lr

00000e68 <GPIO_StructInit>:
*                    which will be initialized.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
     e68:	b480      	push	{r7}
     e6a:	b083      	sub	sp, #12
     e6c:	af00      	add	r7, sp, #0
     e6e:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
     e70:	687b      	ldr	r3, [r7, #4]
     e72:	f64f 72ff 	movw	r2, #65535	; 0xffff
     e76:	801a      	strh	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
     e78:	687b      	ldr	r3, [r7, #4]
     e7a:	f04f 0202 	mov.w	r2, #2
     e7e:	709a      	strb	r2, [r3, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
     e80:	687b      	ldr	r3, [r7, #4]
     e82:	f04f 0204 	mov.w	r2, #4
     e86:	70da      	strb	r2, [r3, #3]
}
     e88:	f107 070c 	add.w	r7, r7, #12
     e8c:	46bd      	mov	sp, r7
     e8e:	bc80      	pop	{r7}
     e90:	4770      	bx	lr
     e92:	bf00      	nop

00000e94 <GPIO_ReadInputDataBit>:
*                    This parameter can be GPIO_Pin_x where x can be (0..15).
* Output         : None
* Return         : The input port pin value.
*******************************************************************************/
u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
{
     e94:	b480      	push	{r7}
     e96:	b085      	sub	sp, #20
     e98:	af00      	add	r7, sp, #0
     e9a:	6078      	str	r0, [r7, #4]
     e9c:	460b      	mov	r3, r1
     e9e:	807b      	strh	r3, [r7, #2]
  u8 bitstatus = 0x00;
     ea0:	f04f 0300 	mov.w	r3, #0
     ea4:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert(IS_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
     ea6:	687b      	ldr	r3, [r7, #4]
     ea8:	689a      	ldr	r2, [r3, #8]
     eaa:	887b      	ldrh	r3, [r7, #2]
     eac:	ea02 0303 	and.w	r3, r2, r3
     eb0:	2b00      	cmp	r3, #0
     eb2:	d003      	beq.n	ebc <GPIO_ReadInputDataBit+0x28>
  {
    bitstatus = (u8)Bit_SET;
     eb4:	f04f 0301 	mov.w	r3, #1
     eb8:	73fb      	strb	r3, [r7, #15]
     eba:	e002      	b.n	ec2 <GPIO_ReadInputDataBit+0x2e>
  }
  else
  {
    bitstatus = (u8)Bit_RESET;
     ebc:	f04f 0300 	mov.w	r3, #0
     ec0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
     ec2:	7bfb      	ldrb	r3, [r7, #15]
}
     ec4:	4618      	mov	r0, r3
     ec6:	f107 0714 	add.w	r7, r7, #20
     eca:	46bd      	mov	sp, r7
     ecc:	bc80      	pop	{r7}
     ece:	4770      	bx	lr

00000ed0 <GPIO_ReadInputData>:
* Input          : - GPIOx: where x can be (A..E) to select the GPIO peripheral.
* Output         : None
* Return         : GPIO input data port value.
*******************************************************************************/
u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
     ed0:	b480      	push	{r7}
     ed2:	b083      	sub	sp, #12
     ed4:	af00      	add	r7, sp, #0
     ed6:	6078      	str	r0, [r7, #4]
  return ((u16)GPIOx->IDR);
     ed8:	687b      	ldr	r3, [r7, #4]
     eda:	689b      	ldr	r3, [r3, #8]
     edc:	b29b      	uxth	r3, r3
}
     ede:	4618      	mov	r0, r3
     ee0:	f107 070c 	add.w	r7, r7, #12
     ee4:	46bd      	mov	sp, r7
     ee6:	bc80      	pop	{r7}
     ee8:	4770      	bx	lr
     eea:	bf00      	nop

00000eec <GPIO_ReadOutputDataBit>:
*                    This parameter can be GPIO_Pin_x where x can be (0..15).
* Output         : None
* Return         : The output port pin value.
*******************************************************************************/
u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
{
     eec:	b480      	push	{r7}
     eee:	b085      	sub	sp, #20
     ef0:	af00      	add	r7, sp, #0
     ef2:	6078      	str	r0, [r7, #4]
     ef4:	460b      	mov	r3, r1
     ef6:	807b      	strh	r3, [r7, #2]
  u8 bitstatus = 0x00;
     ef8:	f04f 0300 	mov.w	r3, #0
     efc:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert(IS_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
     efe:	687b      	ldr	r3, [r7, #4]
     f00:	68da      	ldr	r2, [r3, #12]
     f02:	887b      	ldrh	r3, [r7, #2]
     f04:	ea02 0303 	and.w	r3, r2, r3
     f08:	2b00      	cmp	r3, #0
     f0a:	d003      	beq.n	f14 <GPIO_ReadOutputDataBit+0x28>
  {
    bitstatus = (u8)Bit_SET;
     f0c:	f04f 0301 	mov.w	r3, #1
     f10:	73fb      	strb	r3, [r7, #15]
     f12:	e002      	b.n	f1a <GPIO_ReadOutputDataBit+0x2e>
  }
  else
  {
    bitstatus = (u8)Bit_RESET;
     f14:	f04f 0300 	mov.w	r3, #0
     f18:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
     f1a:	7bfb      	ldrb	r3, [r7, #15]
}
     f1c:	4618      	mov	r0, r3
     f1e:	f107 0714 	add.w	r7, r7, #20
     f22:	46bd      	mov	sp, r7
     f24:	bc80      	pop	{r7}
     f26:	4770      	bx	lr

00000f28 <GPIO_ReadOutputData>:
* Input          : - GPIOx: where x can be (A..E) to select the GPIO peripheral.
* Output         : None
* Return         : GPIO output data port value.
*******************************************************************************/
u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
     f28:	b480      	push	{r7}
     f2a:	b083      	sub	sp, #12
     f2c:	af00      	add	r7, sp, #0
     f2e:	6078      	str	r0, [r7, #4]
  return ((u16)GPIOx->ODR);
     f30:	687b      	ldr	r3, [r7, #4]
     f32:	68db      	ldr	r3, [r3, #12]
     f34:	b29b      	uxth	r3, r3
}
     f36:	4618      	mov	r0, r3
     f38:	f107 070c 	add.w	r7, r7, #12
     f3c:	46bd      	mov	sp, r7
     f3e:	bc80      	pop	{r7}
     f40:	4770      	bx	lr
     f42:	bf00      	nop

00000f44 <GPIO_WriteBit>:
*                       - Bit_SET: to set the port pin
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
{
     f44:	b480      	push	{r7}
     f46:	b083      	sub	sp, #12
     f48:	af00      	add	r7, sp, #0
     f4a:	6078      	str	r0, [r7, #4]
     f4c:	4613      	mov	r3, r2
     f4e:	460a      	mov	r2, r1
     f50:	807a      	strh	r2, [r7, #2]
     f52:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert(IS_GPIO_PIN(GPIO_Pin));
  assert(IS_GPIO_BIT_ACTION(BitVal)); 
  
  if (BitVal != Bit_RESET)
     f54:	787b      	ldrb	r3, [r7, #1]
     f56:	2b00      	cmp	r3, #0
     f58:	d003      	beq.n	f62 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
     f5a:	887a      	ldrh	r2, [r7, #2]
     f5c:	687b      	ldr	r3, [r7, #4]
     f5e:	611a      	str	r2, [r3, #16]
     f60:	e002      	b.n	f68 <GPIO_WriteBit+0x24>
  }
  else
  {
    GPIOx->BRR = GPIO_Pin;
     f62:	887a      	ldrh	r2, [r7, #2]
     f64:	687b      	ldr	r3, [r7, #4]
     f66:	615a      	str	r2, [r3, #20]
  }
}
     f68:	f107 070c 	add.w	r7, r7, #12
     f6c:	46bd      	mov	sp, r7
     f6e:	bc80      	pop	{r7}
     f70:	4770      	bx	lr
     f72:	bf00      	nop

00000f74 <GPIO_Write>:
*                    data register.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
{
     f74:	b480      	push	{r7}
     f76:	b083      	sub	sp, #12
     f78:	af00      	add	r7, sp, #0
     f7a:	6078      	str	r0, [r7, #4]
     f7c:	460b      	mov	r3, r1
     f7e:	807b      	strh	r3, [r7, #2]
  GPIOx->ODR = PortVal;
     f80:	887a      	ldrh	r2, [r7, #2]
     f82:	687b      	ldr	r3, [r7, #4]
     f84:	60da      	str	r2, [r3, #12]
}
     f86:	f107 070c 	add.w	r7, r7, #12
     f8a:	46bd      	mov	sp, r7
     f8c:	bc80      	pop	{r7}
     f8e:	4770      	bx	lr

00000f90 <GPIO_PinLockConfig>:
*                    This parameter can be GPIO_Pin_x where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
{
     f90:	b480      	push	{r7}
     f92:	b085      	sub	sp, #20
     f94:	af00      	add	r7, sp, #0
     f96:	6078      	str	r0, [r7, #4]
     f98:	460b      	mov	r3, r1
     f9a:	807b      	strh	r3, [r7, #2]
  u32 tmp = 0x00010000;
     f9c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
     fa0:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
     fa2:	887b      	ldrh	r3, [r7, #2]
     fa4:	68fa      	ldr	r2, [r7, #12]
     fa6:	ea42 0303 	orr.w	r3, r2, r3
     faa:	60fb      	str	r3, [r7, #12]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
     fac:	687b      	ldr	r3, [r7, #4]
     fae:	68fa      	ldr	r2, [r7, #12]
     fb0:	619a      	str	r2, [r3, #24]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
     fb2:	887a      	ldrh	r2, [r7, #2]
     fb4:	687b      	ldr	r3, [r7, #4]
     fb6:	619a      	str	r2, [r3, #24]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
     fb8:	687b      	ldr	r3, [r7, #4]
     fba:	68fa      	ldr	r2, [r7, #12]
     fbc:	619a      	str	r2, [r3, #24]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
     fbe:	687b      	ldr	r3, [r7, #4]
     fc0:	699b      	ldr	r3, [r3, #24]
     fc2:	60fb      	str	r3, [r7, #12]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
     fc4:	687b      	ldr	r3, [r7, #4]
     fc6:	699b      	ldr	r3, [r3, #24]
     fc8:	60fb      	str	r3, [r7, #12]
}
     fca:	f107 0714 	add.w	r7, r7, #20
     fce:	46bd      	mov	sp, r7
     fd0:	bc80      	pop	{r7}
     fd2:	4770      	bx	lr

00000fd4 <GPIO_EventOutputConfig>:
*                    This parameter can be GPIO_PinSourcex where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
{
     fd4:	b480      	push	{r7}
     fd6:	b085      	sub	sp, #20
     fd8:	af00      	add	r7, sp, #0
     fda:	4602      	mov	r2, r0
     fdc:	460b      	mov	r3, r1
     fde:	71fa      	strb	r2, [r7, #7]
     fe0:	71bb      	strb	r3, [r7, #6]
  u32 tmpreg = 0x00;
     fe2:	f04f 0300 	mov.w	r3, #0
     fe6:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_GPIO_PORT_SOURCE(GPIO_PortSource));
  assert(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    
  tmpreg = AFIO->EVCR;
     fe8:	f240 0300 	movw	r3, #0
     fec:	f2c4 0301 	movt	r3, #16385	; 0x4001
     ff0:	681b      	ldr	r3, [r3, #0]
     ff2:	60fb      	str	r3, [r7, #12]
  /* Clear the PORT[6:4] and PIN[3:0] bits */
  tmpreg &= EVCR_PORTPINCONFIG_MASK;
     ff4:	68fa      	ldr	r2, [r7, #12]
     ff6:	f64f 7380 	movw	r3, #65408	; 0xff80
     ffa:	f2c0 0300 	movt	r3, #0
     ffe:	ea02 0303 	and.w	r3, r2, r3
    1002:	60fb      	str	r3, [r7, #12]
  tmpreg |= (u32)GPIO_PortSource << 0x04;
    1004:	79fb      	ldrb	r3, [r7, #7]
    1006:	ea4f 1303 	mov.w	r3, r3, lsl #4
    100a:	68fa      	ldr	r2, [r7, #12]
    100c:	ea42 0303 	orr.w	r3, r2, r3
    1010:	60fb      	str	r3, [r7, #12]
  tmpreg |= GPIO_PinSource;
    1012:	79bb      	ldrb	r3, [r7, #6]
    1014:	68fa      	ldr	r2, [r7, #12]
    1016:	ea42 0303 	orr.w	r3, r2, r3
    101a:	60fb      	str	r3, [r7, #12]

  AFIO->EVCR = tmpreg;
    101c:	f240 0300 	movw	r3, #0
    1020:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1024:	68fa      	ldr	r2, [r7, #12]
    1026:	601a      	str	r2, [r3, #0]
}
    1028:	f107 0714 	add.w	r7, r7, #20
    102c:	46bd      	mov	sp, r7
    102e:	bc80      	pop	{r7}
    1030:	4770      	bx	lr
    1032:	bf00      	nop

00001034 <GPIO_EventOutputCmd>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EventOutputCmd(FunctionalState NewState)
{
    1034:	b480      	push	{r7}
    1036:	b083      	sub	sp, #12
    1038:	af00      	add	r7, sp, #0
    103a:	4603      	mov	r3, r0
    103c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert(IS_FUNCTIONAL_STATE(NewState));
  
  *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
    103e:	f240 031c 	movw	r3, #28
    1042:	f2c4 2320 	movt	r3, #16928	; 0x4220
    1046:	79fa      	ldrb	r2, [r7, #7]
    1048:	601a      	str	r2, [r3, #0]
}
    104a:	f107 070c 	add.w	r7, r7, #12
    104e:	46bd      	mov	sp, r7
    1050:	bc80      	pop	{r7}
    1052:	4770      	bx	lr

00001054 <GPIO_PinRemapConfig>:
*                    This parameter can be: ENABLE or DISABLE.
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
{
    1054:	b480      	push	{r7}
    1056:	b087      	sub	sp, #28
    1058:	af00      	add	r7, sp, #0
    105a:	6078      	str	r0, [r7, #4]
    105c:	460b      	mov	r3, r1
    105e:	70fb      	strb	r3, [r7, #3]
  u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
    1060:	f04f 0300 	mov.w	r3, #0
    1064:	60bb      	str	r3, [r7, #8]
    1066:	f04f 0300 	mov.w	r3, #0
    106a:	60fb      	str	r3, [r7, #12]
    106c:	f04f 0300 	mov.w	r3, #0
    1070:	613b      	str	r3, [r7, #16]
    1072:	f04f 0300 	mov.w	r3, #0
    1076:	617b      	str	r3, [r7, #20]

  /* Check the parameters */
  assert(IS_GPIO_REMAP(GPIO_Remap));
  assert(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
    1078:	f240 0300 	movw	r3, #0
    107c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1080:	685b      	ldr	r3, [r3, #4]
    1082:	613b      	str	r3, [r7, #16]

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
    1084:	687b      	ldr	r3, [r7, #4]
    1086:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    108a:	ea4f 4313 	mov.w	r3, r3, lsr #16
    108e:	617b      	str	r3, [r7, #20]
  tmp = GPIO_Remap & LSB_MASK;
    1090:	687b      	ldr	r3, [r7, #4]
    1092:	ea4f 4303 	mov.w	r3, r3, lsl #16
    1096:	ea4f 4313 	mov.w	r3, r3, lsr #16
    109a:	60bb      	str	r3, [r7, #8]

  if ((GPIO_Remap & DBGAFR_LOCATION_MASK) == DBGAFR_LOCATION_MASK)
    109c:	687b      	ldr	r3, [r7, #4]
    109e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    10a2:	2b00      	cmp	r3, #0
    10a4:	d004      	beq.n	10b0 <GPIO_PinRemapConfig+0x5c>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
    10a6:	693b      	ldr	r3, [r7, #16]
    10a8:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    10ac:	613b      	str	r3, [r7, #16]
    10ae:	e019      	b.n	10e4 <GPIO_PinRemapConfig+0x90>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
    10b0:	687b      	ldr	r3, [r7, #4]
    10b2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    10b6:	2b00      	cmp	r3, #0
    10b8:	d00d      	beq.n	10d6 <GPIO_PinRemapConfig+0x82>
  {
    tmp1 = ((u32)0x03) << tmpmask;
    10ba:	697b      	ldr	r3, [r7, #20]
    10bc:	f04f 0203 	mov.w	r2, #3
    10c0:	fa02 f303 	lsl.w	r3, r2, r3
    10c4:	60fb      	str	r3, [r7, #12]
    tmpreg &= ~tmp1;
    10c6:	68fb      	ldr	r3, [r7, #12]
    10c8:	ea6f 0303 	mvn.w	r3, r3
    10cc:	693a      	ldr	r2, [r7, #16]
    10ce:	ea02 0303 	and.w	r3, r2, r3
    10d2:	613b      	str	r3, [r7, #16]
    10d4:	e006      	b.n	10e4 <GPIO_PinRemapConfig+0x90>
  }
  else
  {
    tmpreg &= ~tmp;
    10d6:	68bb      	ldr	r3, [r7, #8]
    10d8:	ea6f 0303 	mvn.w	r3, r3
    10dc:	693a      	ldr	r2, [r7, #16]
    10de:	ea02 0303 	and.w	r3, r2, r3
    10e2:	613b      	str	r3, [r7, #16]
  }

  if (NewState != DISABLE)
    10e4:	78fb      	ldrb	r3, [r7, #3]
    10e6:	2b00      	cmp	r3, #0
    10e8:	d011      	beq.n	110e <GPIO_PinRemapConfig+0xba>
  {
    if ((GPIO_Remap & DBGAFR_LOCATION_MASK) == DBGAFR_LOCATION_MASK)
    10ea:	687b      	ldr	r3, [r7, #4]
    10ec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    10f0:	2b00      	cmp	r3, #0
    10f2:	d007      	beq.n	1104 <GPIO_PinRemapConfig+0xb0>
    {
      tmpreg |= (tmp << 0x10);
    10f4:	68bb      	ldr	r3, [r7, #8]
    10f6:	ea4f 4303 	mov.w	r3, r3, lsl #16
    10fa:	693a      	ldr	r2, [r7, #16]
    10fc:	ea42 0303 	orr.w	r3, r2, r3
    1100:	613b      	str	r3, [r7, #16]
    1102:	e004      	b.n	110e <GPIO_PinRemapConfig+0xba>
    }
    else
    {
      tmpreg |= tmp;
    1104:	693a      	ldr	r2, [r7, #16]
    1106:	68bb      	ldr	r3, [r7, #8]
    1108:	ea42 0303 	orr.w	r3, r2, r3
    110c:	613b      	str	r3, [r7, #16]
    }
  }
  AFIO->MAPR = tmpreg;
    110e:	f240 0300 	movw	r3, #0
    1112:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1116:	693a      	ldr	r2, [r7, #16]
    1118:	605a      	str	r2, [r3, #4]
}
    111a:	f107 071c 	add.w	r7, r7, #28
    111e:	46bd      	mov	sp, r7
    1120:	bc80      	pop	{r7}
    1122:	4770      	bx	lr

00001124 <GPIO_EXTILineConfig>:
*                   This parameter can be GPIO_PinSourcex where x can be (0..15).
* Output         : None
* Return         : None
*******************************************************************************/
void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
{
    1124:	b480      	push	{r7}
    1126:	b085      	sub	sp, #20
    1128:	af00      	add	r7, sp, #0
    112a:	4602      	mov	r2, r0
    112c:	460b      	mov	r3, r1
    112e:	71fa      	strb	r2, [r7, #7]
    1130:	71bb      	strb	r3, [r7, #6]
  u32 tmp = 0x00;
    1132:	f04f 0300 	mov.w	r3, #0
    1136:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert(IS_GPIO_PORT_SOURCE(GPIO_PortSource));
  assert(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  
  tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
    1138:	79bb      	ldrb	r3, [r7, #6]
    113a:	f003 0303 	and.w	r3, r3, #3
    113e:	ea4f 0383 	mov.w	r3, r3, lsl #2
    1142:	f04f 020f 	mov.w	r2, #15
    1146:	fa02 f303 	lsl.w	r3, r2, r3
    114a:	60fb      	str	r3, [r7, #12]

  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    114c:	f240 0300 	movw	r3, #0
    1150:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1154:	79ba      	ldrb	r2, [r7, #6]
    1156:	ea4f 0292 	mov.w	r2, r2, lsr #2
    115a:	b2d2      	uxtb	r2, r2
    115c:	4610      	mov	r0, r2
    115e:	f240 0200 	movw	r2, #0
    1162:	f2c4 0201 	movt	r2, #16385	; 0x4001
    1166:	79b9      	ldrb	r1, [r7, #6]
    1168:	ea4f 0191 	mov.w	r1, r1, lsr #2
    116c:	b2c9      	uxtb	r1, r1
    116e:	f101 0102 	add.w	r1, r1, #2
    1172:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    1176:	68fa      	ldr	r2, [r7, #12]
    1178:	ea6f 0202 	mvn.w	r2, r2
    117c:	ea01 0102 	and.w	r1, r1, r2
    1180:	f100 0202 	add.w	r2, r0, #2
    1184:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
    1188:	f240 0300 	movw	r3, #0
    118c:	f2c4 0301 	movt	r3, #16385	; 0x4001
    1190:	79ba      	ldrb	r2, [r7, #6]
    1192:	ea4f 0292 	mov.w	r2, r2, lsr #2
    1196:	b2d2      	uxtb	r2, r2
    1198:	4610      	mov	r0, r2
    119a:	f240 0200 	movw	r2, #0
    119e:	f2c4 0201 	movt	r2, #16385	; 0x4001
    11a2:	79b9      	ldrb	r1, [r7, #6]
    11a4:	ea4f 0191 	mov.w	r1, r1, lsr #2
    11a8:	b2c9      	uxtb	r1, r1
    11aa:	f101 0102 	add.w	r1, r1, #2
    11ae:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    11b2:	f897 c007 	ldrb.w	ip, [r7, #7]
    11b6:	79ba      	ldrb	r2, [r7, #6]
    11b8:	f002 0203 	and.w	r2, r2, #3
    11bc:	ea4f 0282 	mov.w	r2, r2, lsl #2
    11c0:	fa0c f202 	lsl.w	r2, ip, r2
    11c4:	ea41 0102 	orr.w	r1, r1, r2
    11c8:	f100 0202 	add.w	r2, r0, #2
    11cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    11d0:	f107 0714 	add.w	r7, r7, #20
    11d4:	46bd      	mov	sp, r7
    11d6:	bc80      	pop	{r7}
    11d8:	4770      	bx	lr
    11da:	bf00      	nop

000011dc <APBAHBPrescTable>:
    11dc:	0000 0000 0201 0403 0201 0403 0706 0908     ................

000011ec <ADCPrescTable>:
    11ec:	0402 0806                                   ....
